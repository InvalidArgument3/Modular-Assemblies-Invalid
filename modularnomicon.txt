using Modular_Assemblies.Data.Scripts.AssemblyScripts.Definitions;
using Sandbox.ModAPI;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using VRage.Game.Components;
using VRage.Utils;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts
{
    [MySessionComponentDescriptor(MyUpdateOrder.AfterSimulation)]
    public class Assemblies_SessionInit : MySessionComponentBase
    {
        public static Assemblies_SessionInit I;
        AssemblyPartManager AssemblyPartManager = new AssemblyPartManager();
        DefinitionHandler DefinitionHandler = new DefinitionHandler();
        public static bool DebugMode = false;
        public Random random = new Random();

        #region Base Methods

        public override void LoadData()
        {
            I = this;

            AssemblyPartManager.Init();
            DefinitionHandler.Init();

            //if (!MyAPIGateway.Multiplayer.MultiplayerActive)
            //{
                MyAPIGateway.Utilities.ShowMessage("Modular Assemblies", $"Run !mwHelp for commands.");
                MyAPIGateway.Utilities.MessageEnteredSender += ChatCommandHandler;
            //}
            //else
            //    MyAPIGateway.Utilities.ShowMessage("Modular Assemblies", $"Commands disabled, load into a singleplayer world for testing. | {DefinitionHandler.I.ModularDefinitions.Count} definitions loaded.");
        }

        public override void UpdateAfterSimulation()
        {
            try
            {
                AssemblyPartManager.UpdateAfterSimulation();
            }
            catch (Exception e)
            {
                MyLog.Default.WriteLineAndConsole("Handled exception in Modular Assemblies!\n" + e.ToString());
            }
        }

        protected override void UnloadData()
        {
            // None of this should run on client.

            MyLog.Default.WriteLineAndConsole("Modular Assemblies: AssemblyPartManager closing...");

            //if (!MyAPIGateway.Multiplayer.MultiplayerActive)
            //{
                MyAPIGateway.Utilities.MessageEnteredSender -= ChatCommandHandler;
            //}

            AssemblyPartManager.Unload();
            DefinitionHandler.Unload();

            I = null;
            MyLog.Default.WriteLineAndConsole("Modular Assemblies: Finished unloading.");
        }

        #endregion

        private void ChatCommandHandler(ulong sender, string messageText, ref bool sendToOthers)
        {
            if (!messageText.StartsWith("!"))
                return;

            string[] split = messageText.Split(' ');
            switch (split[0].ToLower())
            {
                case "!mwhelp":
                    MyAPIGateway.Utilities.ShowMessage("Modular Assemblies", "Commands:\n!mwHelp - Prints all commands\n!mwDebug - Toggles debug draw");
                    sendToOthers = false;
                    break;
                case "!mwdebug":
                    DebugMode = !DebugMode;
                    sendToOthers = false;
                    break;
            }
        }
    }
}
﻿using Sandbox.Common.ObjectBuilders;
using Sandbox.Game;
using Sandbox.Game.Entities.Cube;
using Sandbox.ModAPI;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Modular_Assemblies.Data.Scripts.AssemblyScripts.Definitions;
using VRage.Game;
using VRage.Game.Components;
using VRage.Game.ModAPI;
using VRage.ModAPI;
using VRage.ObjectBuilders;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts
{
    /// <summary>
    /// Attached to every part in a AssemblyDefinition.
    /// </summary>
    public class AssemblyPart
    {
        public IMySlimBlock Block;
        public bool IsBaseBlock = false;

        public PhysicalAssembly MemberAssembly
        {
            get
            {
                return _memberAssembly;
            }
            set
            {
                if (value != _memberAssembly)
                {
                    if (!_memberAssembly?.IsClosing ?? false)
                        _memberAssembly.RemovePart(this);
                    _memberAssembly = value;
                }
            }
        }
        private PhysicalAssembly _memberAssembly = null;

        public HashSet<AssemblyPart> ConnectedParts = new HashSet<AssemblyPart>();
        public ModularDefinition AssemblyDefinition;

        public int PrevAssemblyId = -1;

        public AssemblyPart(IMySlimBlock block, ModularDefinition AssemblyDefinition)
        {
            this.Block = block;
            this.AssemblyDefinition = AssemblyDefinition;

            IsBaseBlock = AssemblyDefinition.BaseBlockSubtype == Block.BlockDefinition.Id.SubtypeName;

            if (AssemblyPartManager.I.AllAssemblyParts.ContainsKey(block))
                return;

            AssemblyPartManager.I.AllAssemblyParts.Add(block, this);

            AssemblyPartManager.I.QueueConnectionCheck(this);
        }

        public void DoConnectionCheck(bool cascadingUpdate = false, HashSet<AssemblyPart> visited = null)
        {
            if (visited == null)
                visited = new HashSet<AssemblyPart>();

            if (visited.Contains(this))
                return;

            visited.Add(this);
            ConnectedParts = GetValidNeighborParts();

            // If no neighbors AND (is base block OR base block not defined), create assembly.
            if (ConnectedParts.Count == 0 && (AssemblyDefinition.BaseBlockSubtype == null || IsBaseBlock))
            {
                _memberAssembly = new PhysicalAssembly(AssemblyPartManager.I.CreatedPhysicalAssemblies, this, AssemblyDefinition);
                // Trigger cascading update
                if (IsBaseBlock || cascadingUpdate)
                {
                    MyAPIGateway.Utilities.ShowNotification("" + GetValidNeighborParts().Count);
                    foreach (var neighbor in GetValidNeighborParts())
                        if (neighbor.MemberAssembly == null)
                            neighbor.DoConnectionCheck(true);
                }
                return;
            }
            
            HashSet<PhysicalAssembly> assemblies = new HashSet<PhysicalAssembly>();
            foreach (var neighbor in ConnectedParts)
            {
                if (neighbor.MemberAssembly != null)
                {
                    assemblies.Add(neighbor.MemberAssembly);
                }
                neighbor.ConnectedParts = neighbor.GetValidNeighborParts();
            }

            // Double-checking for null assemblies
            if (assemblies.Count == 0 && (AssemblyDefinition.BaseBlockSubtype == null || IsBaseBlock))
            {
                _memberAssembly = new PhysicalAssembly(AssemblyPartManager.I.CreatedPhysicalAssemblies, this, AssemblyDefinition);
                // Trigger cascading update
                if (IsBaseBlock || cascadingUpdate)
                {
                    MyAPIGateway.Utilities.ShowNotification("" + GetValidNeighborParts().Count);
                    foreach (var neighbor in GetValidNeighborParts())
                        if (neighbor.MemberAssembly == null)
                            neighbor.DoConnectionCheck(true);
                }
                return;
            }
            
            PhysicalAssembly largestAssembly = MemberAssembly;
            foreach (var assembly in assemblies)
            {
                if (assembly.ComponentParts.Count > (largestAssembly?.ComponentParts.Count ?? -1))
                {
                    largestAssembly?.MergeWith(assembly);
                    largestAssembly = assembly;
                }
                else
                {
                    assembly.MergeWith(largestAssembly);
                }
            }
            largestAssembly?.AddPart(this);
            
            // Trigger cascading update
            if (IsBaseBlock || cascadingUpdate)
            {
                //debug notification begone
                //MyAPIGateway.Utilities.ShowNotification("" + GetValidNeighborParts().Count);

                foreach (var neighbor in GetValidNeighborParts())
                {
                    if (neighbor.MemberAssembly == null)
                        neighbor.DoConnectionCheck(true, visited);
                }
            }

        }

        public void PartRemoved()
        {
            MemberAssembly?.RemovePart(this);
            foreach (var neighbor in ConnectedParts)
                neighbor.ConnectedParts.Remove(this);

            DefinitionHandler.I.SendOnPartRemove(AssemblyDefinition.Name, MemberAssembly?.AssemblyId ?? -1, Block.FatBlock.EntityId, IsBaseBlock);
            if (Block.Integrity <= 0)
                DefinitionHandler.I.SendOnPartDestroy(AssemblyDefinition.Name, MemberAssembly?.AssemblyId ?? -1, Block.FatBlock.EntityId, IsBaseBlock);
        }

        /// <summary>
        /// Returns attached (as per AssemblyPart) neighbor blocks.
        /// </summary>
        /// <returns></returns>
        public List<IMySlimBlock> GetValidNeighbors(bool MustShareAssembly = false)
        {
            List<IMySlimBlock> neighbors = new List<IMySlimBlock>();
            Block.GetNeighbours(neighbors);

            neighbors.RemoveAll(nBlock => !AssemblyDefinition.DoesBlockConnect(Block, nBlock, true));

            if (MustShareAssembly)
                neighbors.RemoveAll(nBlock =>
                {
                    AssemblyPart part;
                    if (!AssemblyPartManager.I.AllAssemblyParts.TryGetValue(nBlock, out part))
                        return true;
                    return part.MemberAssembly != this.MemberAssembly;
                });

            return neighbors;
        }

        /// <summary>
        /// Returns attached (as per AssemblyPart) neighbor blocks's parts.
        /// </summary>
        /// <returns></returns>
        public HashSet<AssemblyPart> GetValidNeighborParts(bool MustShareAssembly = false)
        {
            List<AssemblyPart> validNeighbors = new List<AssemblyPart>();
            foreach (var nBlock in GetValidNeighbors())
            {
                AssemblyPart nBlockPart;
                if (!AssemblyPartManager.I.AllAssemblyParts.TryGetValue(nBlock, out nBlockPart))
                    continue;

                if (!MustShareAssembly || nBlockPart.MemberAssembly == MemberAssembly)
                    validNeighbors.Add(nBlockPart);
            }

            return validNeighbors.ToHashSet();
        }

        public void GetAllConnectedParts(ref HashSet<AssemblyPart> connectedParts)
        {
            // If a block has already been added, return.
            if (!connectedParts.Add(this))
                return;
            foreach (var part in ConnectedParts)
            {
                part.GetAllConnectedParts(ref connectedParts);
            }
        }
    }
}﻿using Modular_Assemblies.Data.Scripts.AssemblyScripts.Definitions;
using Sandbox.ModAPI;
using System;
using System.Collections.Generic;
using System.Linq;
using VRage.Game.Components;
using VRage.Game.ModAPI;
using VRage.ModAPI;
using VRage.Utils;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts
{
    /// <summary>
    /// Creates and manages all AssemblyParts and PhysicalAssemblies.
    /// </summary>
    public class AssemblyPartManager
    {
        public static AssemblyPartManager I;

        /// <summary>
        /// Every single AssemblyPart in the world.
        /// </summary>
        public Dictionary<IMySlimBlock, AssemblyPart> AllAssemblyParts = new Dictionary<IMySlimBlock, AssemblyPart>();

        /// <summary>
        /// Every single PhysicalAssembly in the world.
        /// </summary>
        public Dictionary<int, PhysicalAssembly> AllPhysicalAssemblies = new Dictionary<int, PhysicalAssembly>();
        public int CreatedPhysicalAssemblies = 0;

        private HashSet<IMySlimBlock> QueuedBlockAdds = new HashSet<IMySlimBlock>();
        private HashSet<AssemblyPart> QueuedConnectionChecks = new HashSet<AssemblyPart>();
        private Dictionary<AssemblyPart, PhysicalAssembly> QueuedAssemblyChecks = new Dictionary<AssemblyPart, PhysicalAssembly>();

        public Action<int> OnAssemblyClose;

        public void QueueBlockAdd(IMySlimBlock block) => QueuedBlockAdds.Add(block);
        public void QueueConnectionCheck(AssemblyPart part)
        {
            QueuedConnectionChecks.Add(part);
        }
        public void QueueAssemblyCheck(AssemblyPart part, PhysicalAssembly assembly)
        {
            if (!QueuedAssemblyChecks.ContainsKey(part))
                QueuedAssemblyChecks.Add(part, assembly);
        }

        public void Init()
        {
            MyLog.Default.WriteLineAndConsole("Modular Assemblies: AssemblyPartManager loading...");

            I = this;

            // None of this should run on client.
            //if (!MyAPIGateway.Multiplayer.IsServer)
            //    return;

            MyAPIGateway.Entities.OnEntityAdd += OnGridAdd;
            MyAPIGateway.Entities.OnEntityRemove += OnGridRemove;
        }

        public void Unload()
        {
            I = null; // important for avoiding this object to remain allocated in memory
            AllAssemblyParts.Clear();
            AllPhysicalAssemblies.Clear();
            OnAssemblyClose = null;

            // None of this should run on client.
            //if (!MyAPIGateway.Multiplayer.IsServer)
            //    return;

            MyLog.Default.WriteLineAndConsole("Modular Assemblies: AssemblyPartManager closing...");

            MyAPIGateway.Entities.OnEntityAdd -= OnGridAdd;
            MyAPIGateway.Entities.OnEntityRemove -= OnGridRemove;
        }



        

        
        public void UpdateAfterSimulation()
        {
            // Queue gridadds to account for world load/grid pasting
            ProcessQueuedBlockAdds();
            // Queue partadds to account for world load/grid pasting
            ProcessQueuedConnectionChecks();

            ProcessQueuedAssemblyChecks();

            foreach (var assembly in AllPhysicalAssemblies.Values)
            {
                assembly.Update();
            }

            if (Assemblies_SessionInit.DebugMode)
            {
                MyAPIGateway.Utilities.ShowNotification($"Assemblies: {AllPhysicalAssemblies.Count} | Parts: {AllAssemblyParts.Count}", 1000 / 60);
                MyAPIGateway.Utilities.ShowNotification($"Definitions: {DefinitionHandler.I.ModularDefinitions.Count}", 1000 / 60);
            }
        }

        private void ProcessQueuedBlockAdds()
        {
            lock (QueuedBlockAdds)
            {
                foreach (var queuedBlock in QueuedBlockAdds)
                {
                    OnBlockAdd(queuedBlock);
                }
                QueuedBlockAdds.Clear();
            }
        }

        private void ProcessQueuedConnectionChecks()
        {
            HashSet<AssemblyPart> queuedParts;
            lock (QueuedConnectionChecks)
            {
                queuedParts = new HashSet<AssemblyPart>(QueuedConnectionChecks);
                QueuedConnectionChecks.Clear();
            }

            foreach (var queuedPart in queuedParts)
            {
                queuedPart.DoConnectionCheck();
            }
        }

        private void ProcessQueuedAssemblyChecks()
        {
            Dictionary<AssemblyPart, PhysicalAssembly> queuedAssemblies;
            lock (QueuedAssemblyChecks)
            {
                queuedAssemblies = new Dictionary<AssemblyPart, PhysicalAssembly>(QueuedAssemblyChecks);
                QueuedAssemblyChecks.Clear();
            }

            foreach (var queuedAssembly in queuedAssemblies)
            {
                queuedAssembly.Key.DoConnectionCheck();
            }
        }

        private void OnGridAdd(IMyEntity entity)
        {
            if (!(entity is IMyCubeGrid))
                return;

            IMyCubeGrid grid = (IMyCubeGrid) entity;

            // Exclude projected and held grids
            if (grid.Physics == null)
                return;

            grid.OnBlockAdded += OnBlockAdd;
            grid.OnBlockRemoved += OnBlockRemove;

            List<IMySlimBlock> existingBlocks = new List<IMySlimBlock>();
            grid.GetBlocks(existingBlocks);
            foreach (var block in existingBlocks)
                QueuedBlockAdds.Add(block);
        }

        private void OnBlockAdd(IMySlimBlock block)
        {
            if (block == null)
                return;
            try
            {
                foreach (var modularDefinition in DefinitionHandler.I.ModularDefinitions)
                {
                    if (!modularDefinition.IsBlockAllowed(block))
                        return;

                    AssemblyPart w = new AssemblyPart(block, modularDefinition);
                    // No further init work is needed.
                    // Not returning because a part can have multiple assemblies.
                }
            }
            catch (Exception e)
            {
                MyLog.Default.WriteLineAndConsole("Handled exception in Modular Assemblies.AssemblyPartManager.OnBlockAdd()!\n" + e.ToString());
            }
        }

        private void OnGridRemove(IMyEntity entity)
        {
            if (!(entity is IMyCubeGrid))
                return;

            IMyCubeGrid grid = (IMyCubeGrid)entity;

            // Exclude projected and held grids
            if (grid.Physics == null)
                return;

            grid.OnBlockAdded -= OnBlockAdd;
            grid.OnBlockRemoved -= OnBlockRemove;

            List<AssemblyPart> toRemove = new List<AssemblyPart>();
            HashSet<PhysicalAssembly> toRemoveAssemblies = new HashSet<PhysicalAssembly>();
            foreach (var partKvp in AllAssemblyParts)
            {
                if (partKvp.Key.CubeGrid == grid)
                {
                    toRemove.Add(partKvp.Value);
                    if (partKvp.Value.MemberAssembly != null)
                        toRemoveAssemblies.Add(partKvp.Value.MemberAssembly);
                }
            }
            foreach (var deadAssembly in toRemoveAssemblies)
                deadAssembly.Close();
            foreach (var deadPart in toRemove)
                AllAssemblyParts.Remove(deadPart.Block);
        }

        private void OnBlockRemove(IMySlimBlock block)
        {
            if (block == null)
                return;
            AssemblyPart part;
            if (AllAssemblyParts.TryGetValue(block, out part))
            {
                part.PartRemoved();
                AllAssemblyParts.Remove(block);
            }
        }
    }
}
﻿using Modular_Assemblies.Data.Scripts.AssemblyScripts.DebugDraw;
using Sandbox.Definitions;
using Sandbox.ModAPI;
using System;
using System.Collections.Generic;
using VRage.Game.ModAPI;
using VRage.Utils;
using VRageMath;
using static Modular_Assemblies.Data.Scripts.AssemblyScripts.Definitions.DefinitionDefs;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts
{
    public class ModularDefinition
    {

        public string[] AllowedBlocks = null;

        public Dictionary<string, Dictionary<Vector3I, string[]>> AllowedConnections = null;

        public string BaseBlockSubtype = null;
        public string Name = null;


        public static ModularDefinition Load(PhysicalDefinition definition)
        {
            ModularDefinition def = new ModularDefinition()
            {
                AllowedBlocks = definition.AllowedBlocks,
                AllowedConnections = definition.AllowedConnections,
                BaseBlockSubtype = definition.BaseBlock,
                Name = definition.Name,
            };
            
            if (def.AllowedBlocks == null || def.AllowedConnections == null || def.Name == null)
            {
                MyLog.Default.WriteLineAndConsole("Modular Assemblies: Failed to create new ModularDefinition for " + definition.Name);
                MyAPIGateway.Utilities.ShowMessage("Modular Assemblies", "Failed to create new ModularDefinition for " + definition.Name);
                return null;
            }

            MyLog.Default.WriteLineAndConsole("Modular Assemblies: Created new ModularDefinition for " + definition.Name);
            return def;
        }

        public bool DoesBlockConnect(IMySlimBlock block, IMySlimBlock adajent, bool lineCheck = true)
        {
            // Check if adjacent block connects first, but don't make an infinite loop
            if (lineCheck)
                if (!DoesBlockConnect(adajent, block, false))
                    return false;
            
            // Get local offset for below
            Matrix localOrientation;
            block.Orientation.GetMatrix(out localOrientation);

            Dictionary<Vector3I, string[]> connection;
            if (AllowedConnections.TryGetValue(block.BlockDefinition.Id.SubtypeName, out connection))
            {
                foreach (var allowedPosKvp in connection)
                {
                    Vector3I offsetAllowedPos = (Vector3I)Vector3D.Rotate(allowedPosKvp.Key, localOrientation) + block.Position;

                    // If list is empty OR block is not in whitelist, continue.
                    if (allowedPosKvp.Value?.Length == 0 || !(allowedPosKvp.Value?.Contains(adajent.BlockDefinition.Id.SubtypeName) ?? true))
                    {
                        if (Assemblies_SessionInit.DebugMode)
                            DebugDrawManager.AddGridPoint(offsetAllowedPos, block.CubeGrid, Color.Red, 3);
                        continue;
                    }

                    if (offsetAllowedPos.IsInsideInclusiveEnd(adajent.Min, adajent.Max))
                    {
                        if (Assemblies_SessionInit.DebugMode)
                            DebugDrawManager.AddGridPoint(offsetAllowedPos, block.CubeGrid, Color.Green, 3);
                        return true;
                    }
                    if (Assemblies_SessionInit.DebugMode)
                        DebugDrawManager.AddGridPoint(offsetAllowedPos, block.CubeGrid, Color.Red, 3);
                }
                return false;
            }

            // Return true by default.
            return true;
        }

        public bool IsTypeAllowed(string type)
        {
            foreach (string id in AllowedBlocks)
                if (type == id)
                    return true;
            return false;
        }

        public bool IsBlockAllowed(IMySlimBlock block)
        {
            return IsTypeAllowed(block.BlockDefinition.Id.SubtypeName);
        }
    }
}
﻿using Modular_Assemblies.Data.Scripts.AssemblyScripts.DebugDraw;
using Modular_Assemblies.Data.Scripts.AssemblyScripts.Definitions;
using Sandbox.ModAPI;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using VRage.Game.ModAPI;
using VRageMath;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts
{
    /// <summary>
    /// The collection of AssemblyParts attached to a modular assembly base.
    /// </summary>
    public class PhysicalAssembly
    {
        public AssemblyPart BasePart = null;
        public List<AssemblyPart> ComponentParts = new List<AssemblyPart>();
        public ModularDefinition AssemblyDefinition;
        public int AssemblyId = -1;
        public bool IsClosing = false;

        private Color color;

        public void Update()
        {
            if (Assemblies_SessionInit.DebugMode)
            {
                foreach (var part in ComponentParts)
                {
                    DebugDrawManager.AddGridPoint(part.Block.Position, part.Block.CubeGrid, color, 0f);
                    foreach (var conPart in part.ConnectedParts)
                        DebugDrawManager.AddLine(DebugDrawManager.GridToGlobal(part.Block.Position, part.Block.CubeGrid), DebugDrawManager.GridToGlobal(conPart.Block.Position, part.Block.CubeGrid), color, 0f);
                }
                //DebugDrawManager.AddGPS($"ASM {AssemblyId} Parts: {ComponentParts.Count}", ComponentParts[0].Block.FatBlock.GetPosition(), 1/60f);
            }
        }

        public PhysicalAssembly(int id, AssemblyPart basePart, ModularDefinition AssemblyDefinition)
        {
            if (AssemblyDefinition.BaseBlockSubtype != null)
                BasePart = basePart;
            this.AssemblyDefinition = AssemblyDefinition;
            this.AssemblyId = id;
            AssemblyPartManager.I.CreatedPhysicalAssemblies++;

            if (AssemblyPartManager.I.AllPhysicalAssemblies.ContainsKey(id))
                throw new Exception("Duplicate assembly ID!");
            AssemblyPartManager.I.AllPhysicalAssemblies.Add(id, this);


            color = new Color(Assemblies_SessionInit.I.random.Next(255), Assemblies_SessionInit.I.random.Next(255), Assemblies_SessionInit.I.random.Next(255));

            AddPart(basePart);
            AssemblyPartManager.I.QueueAssemblyCheck(basePart, this);
        }

        public void AddPart(AssemblyPart part)
        {
            if (ComponentParts.Contains(part) || part.Block == null)
                return;

            ComponentParts.Add(part);
            part.MemberAssembly = this;
            if (part.PrevAssemblyId != AssemblyId)
                DefinitionHandler.I.SendOnPartAdd(AssemblyDefinition.Name, AssemblyId, part.Block.FatBlock.EntityId, /*part == basePart*/ ComponentParts.Count == 1);
            part.PrevAssemblyId = AssemblyId;
        }

        public void RemovePart(AssemblyPart part)
        {
            if (!ComponentParts.Remove(part))
                return;

            HashSet<AssemblyPart> neighbors = part.ConnectedParts;

            foreach (var neighbor in neighbors)
            {
                neighbor.ConnectedParts = neighbor.GetValidNeighborParts();
            }

            if (ComponentParts.Count == 0 || part == BasePart)
            {
                Close();
                return;
            }

            if (neighbors.Count == 1)
                return;

            List<HashSet<AssemblyPart>> partLoops = new List<HashSet<AssemblyPart>>();
            foreach (var neighbor in neighbors)
            {
                HashSet<AssemblyPart> connectedParts = new HashSet<AssemblyPart>();
                neighbor.GetAllConnectedParts(ref connectedParts);

                partLoops.Add(connectedParts);
            }

            if (partLoops.Count <= 1)
                return;

            // Split apart, keeping this assembly as the largest loop.
            HashSet<AssemblyPart> largestLoop = partLoops[0];
            foreach (var loop in partLoops)
            {
                if (loop.Count > largestLoop.Count)
                    largestLoop = loop;
            }
            foreach (var componentPart in ComponentParts.ToArray())
            {
                if (!largestLoop.Contains(componentPart))
                {
                    ComponentParts.Remove(componentPart);
                    componentPart.MemberAssembly = null;
                    componentPart.ConnectedParts.Clear();
                    AssemblyPartManager.I.QueueConnectionCheck(componentPart);
                }
            }
        }

        public void Close()
        {
            IsClosing = true;
            AssemblyPartManager.I.OnAssemblyClose?.Invoke(AssemblyId);
            if (ComponentParts != null)
            {
                foreach (var part in ComponentParts)
                {
                    //nullcheck for good luck :^)
                    if (part?.MemberAssembly != this)
                        continue;

                    part.MemberAssembly = null;
                    part.ConnectedParts.Clear();
                }
            }
            ComponentParts = null;
            //basePart = null;
            AssemblyPartManager.I.AllPhysicalAssemblies.Remove(AssemblyId);
        }

        

        public void MergeWith(PhysicalAssembly assembly)
        {
            if (assembly == null || assembly == this)
                return;

            foreach (var part in ComponentParts.ToArray())
            {
                assembly.AddPart(part);
            }
            Close();
        }
    }
}
﻿using Sandbox.ModAPI;
using System;
using System.Collections.Generic;
using System.Linq;
using VRage;
using VRage.Game;
using VRage.Game.Components;
using VRage.Game.ModAPI;
using VRage.Utils;
using VRageMath;
using static VRageRender.MyBillboard;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts.DebugDraw
{
    [MySessionComponentDescriptor(MyUpdateOrder.BeforeSimulation)]
    public class DebugDrawManager : MySessionComponentBase
    {
        // i'm gonna kiss digi on the 

        private static DebugDrawManager Instance;
        protected static readonly MyStringId MaterialDot = MyStringId.GetOrCompute("WhiteDot");
        protected static readonly MyStringId MaterialSquare = MyStringId.GetOrCompute("Square");

        private Dictionary<Vector3D, MyTuple<long, Color>> QueuedPoints = new Dictionary<Vector3D, MyTuple<long, Color>>();
        private Dictionary<IMyGps, long> QueuedGps = new Dictionary<IMyGps, long>();
        private Dictionary<Vector3I, MyTuple<long, Color, IMyCubeGrid>> QueuedGridPoints = new Dictionary<Vector3I, MyTuple<long, Color, IMyCubeGrid>>();

        private Dictionary<MyTuple<Vector3D, Vector3D>, MyTuple<long, Color>> QueuedLinePoints = new Dictionary<MyTuple<Vector3D, Vector3D>, MyTuple<long, Color>>();

        public override void LoadData()
        {
            Instance = this;
        }

        protected override void UnloadData()
        {
            Instance = null;
        }

        public static void AddPoint(Vector3D globalPos, Color color, float duration)
        {
            if (Instance == null)
                return;

            if (Instance.QueuedPoints.ContainsKey(globalPos))
                Instance.QueuedPoints[globalPos] = new MyTuple<long, Color>(DateTime.Now.Ticks + (long)(duration * TimeSpan.TicksPerSecond), color);
            else
                Instance.QueuedPoints.Add(globalPos, new MyTuple<long, Color>(DateTime.Now.Ticks + (long)(duration * TimeSpan.TicksPerSecond), color));
        }

        public static void AddGPS(string name, Vector3D position, float duration)
        {
            IMyGps gps = MyAPIGateway.Session.GPS.Create(name, string.Empty, position, showOnHud: true, temporary: true);
            //gps.DiscardAt = TimeSpan.FromSeconds(duration);
            //MyAPIGateway.Session.GPS.AddLocalGps(gps);
            Instance.QueuedGps.Add(gps, DateTime.Now.Ticks + (long)(duration * TimeSpan.TicksPerSecond));
        }

        public static void AddGridGPS(string name, Vector3I gridPosition, IMyCubeGrid grid, float duration)
        {
            AddGPS(name, GridToGlobal(gridPosition, grid), duration);
        }

        public static void AddGridPoint(Vector3I blockPos, IMyCubeGrid grid, Color color, float duration)
        {
            if (Instance == null)
                return;

            if (Instance.QueuedGridPoints.ContainsKey(blockPos))
                Instance.QueuedGridPoints[blockPos] = new MyTuple<long, Color, IMyCubeGrid>(DateTime.Now.Ticks + (long)(duration * TimeSpan.TicksPerSecond), color, grid);
            else
                Instance.QueuedGridPoints.Add(blockPos, new MyTuple<long, Color, IMyCubeGrid>(DateTime.Now.Ticks + (long)(duration * TimeSpan.TicksPerSecond), color, grid));
        }

        public static void AddLine(Vector3D origin, Vector3D destination, Color color, float duration)
        {
            if (Instance == null)
                return;

            MyTuple<Vector3D, Vector3D> key = new MyTuple<Vector3D, Vector3D>(origin, destination);
            if (Instance.QueuedLinePoints.ContainsKey(key))
                Instance.QueuedLinePoints[key] = new MyTuple<long, Color>(DateTime.Now.Ticks + (long)(duration * TimeSpan.TicksPerSecond), color);
            else
                Instance.QueuedLinePoints.Add(key, new MyTuple<long, Color>(DateTime.Now.Ticks + (long)(duration * TimeSpan.TicksPerSecond), color));
        }

        public override void Draw()
        {
            base.Draw();

            foreach (var key in QueuedPoints.Keys.ToList())
            {
                DrawPoint0(key, QueuedPoints[key].Item2);

                if (DateTime.Now.Ticks > QueuedPoints[key].Item1)
                    QueuedPoints.Remove(key);
            }

            foreach (var key in QueuedGps.Keys.ToList())
            {
                if (DateTime.Now.Ticks > QueuedGps[key])
                {
                    MyAPIGateway.Session.GPS.RemoveLocalGps(key);
                    QueuedGps.Remove(key);
                }
            }

            foreach (var key in QueuedGridPoints.Keys.ToList())
            {
                DrawGridPoint0(key, QueuedGridPoints[key].Item3, QueuedGridPoints[key].Item2);

                if (DateTime.Now.Ticks > QueuedGridPoints[key].Item1)
                    QueuedGridPoints.Remove(key);
            }

            foreach (var key in QueuedLinePoints.Keys.ToList())
            {
                DrawLine0(key.Item1, key.Item2, QueuedLinePoints[key].Item2);

                if (DateTime.Now.Ticks > QueuedLinePoints[key].Item1)
                    QueuedLinePoints.Remove(key);
            }
        }

        private void DrawPoint0(Vector3D globalPos, Color color)
        {
            //MyTransparentGeometry.AddPointBillboard(MaterialDot, color, globalPos, 1.25f, 0, blendType: BlendTypeEnum.PostPP);
            float depthScale = ToAlwaysOnTop(ref globalPos);
            MyTransparentGeometry.AddPointBillboard(MaterialDot, color * OnTopColorMul, globalPos, 0.5f * depthScale, 0, blendType: BlendTypeEnum.PostPP);
        }

        private void DrawGridPoint0(Vector3I blockPos, IMyCubeGrid grid, Color color)
        {
            DrawPoint0(GridToGlobal(blockPos, grid), color);
        }

        private void DrawLine0(Vector3D origin, Vector3D destination, Color color)
        {
            float length = (float)(destination - origin).Length();
            Vector3D direction = (destination - origin) / length;

            MyTransparentGeometry.AddLineBillboard(MaterialSquare, color, origin, direction, length, 0.5f, blendType: BlendTypeEnum.PostPP);

            float depthScale = ToAlwaysOnTop(ref origin);
            direction *= depthScale;

            MyTransparentGeometry.AddLineBillboard(MaterialSquare, color * OnTopColorMul, origin, direction, length, 0.5f * depthScale, blendType: BlendTypeEnum.PostPP);
        }

        public static Vector3D GridToGlobal(Vector3I position, IMyCubeGrid grid)
        {
            return Vector3D.Rotate(((Vector3D)position) * 2.5f, grid.WorldMatrix) + grid.GetPosition();
        }

        protected const float OnTopColorMul = 0.5f;
        const float DepthRatioF = 0.01f;
        protected static float ToAlwaysOnTop(ref Vector3D position)
        {
            MatrixD camMatrix = MyAPIGateway.Session.Camera.WorldMatrix;
            position = camMatrix.Translation + ((position - camMatrix.Translation) * DepthRatioF);

            return DepthRatioF;
        }
    }
}
﻿using Sandbox.ModAPI;
using System;
using System.Collections.Generic;
using System.Linq;
using VRage.Game.Entity;
using VRage.Game.ModAPI;
using VRage.ModAPI;
using VRage.Utils;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts.Definitions
{
    internal class ApiDefinitions
    {
        internal readonly Dictionary<string, Delegate> ModApiMethods;

        internal ApiDefinitions()
        {
            ModApiMethods = new Dictionary<string, Delegate>()
            {
                ["GetAllParts"] = new Func<MyEntity[]>(GetAllParts),
                ["GetAllAssemblies"] = new Func<int[]>(GetAllAssemblies),
                ["GetMemberParts"] = new Func<int, MyEntity[]>(GetMemberParts),
                ["GetConnectedBlocks"] = new Func<MyEntity, bool, MyEntity[]>(GetConnectedBlocks),
                ["GetBasePart"] = new Func<int, MyEntity>(GetBasePart),
                ["IsDebug"] = new Func<bool>(IsDebug),
                ["GetContainingAssembly"] = new Func<MyEntity, int>(GetContainingAssembly),
                ["GetAssemblyGrid"] = new Func<int, IMyCubeGrid>(GetAssemblyGrid),
                ["AddOnAssemblyClose"] = new Action<Action<int>>(AddOnAssemblyClose),
                ["RemoveOnAssemblyClose"] = new Action<Action<int>>(RemoveOnAssemblyClose),
            };
        }

        private bool IsDebug()
        {
            return Assemblies_SessionInit.DebugMode;
        }

        private MyEntity[] GetAllParts()
        {
            List<MyEntity> parts = new List<MyEntity>();
            foreach (var block in AssemblyPartManager.I.AllAssemblyParts.Keys)
                if (block.FatBlock != null)
                    parts.Add((MyEntity)block.FatBlock);
            return parts.ToArray();
        }

        private int[] GetAllAssemblies()
        {
            return AssemblyPartManager.I.AllPhysicalAssemblies.Keys.ToArray();
        }

        private MyEntity[] GetMemberParts(int assemblyId)
        {
            PhysicalAssembly wep;
            if (!AssemblyPartManager.I.AllPhysicalAssemblies.TryGetValue(assemblyId, out wep))
                return Array.Empty<MyEntity>();

            List<MyEntity> parts = new List<MyEntity>();
            foreach (var part in wep.ComponentParts)
                if (part.Block.FatBlock != null)
                    parts.Add((MyEntity)part.Block.FatBlock);

            return parts.ToArray();
        }

        private MyEntity[] GetConnectedBlocks(MyEntity blockEntity, bool useCached)
        {
            var block = blockEntity as IMyCubeBlock;
            if (block == null)
                return Array.Empty<MyEntity>();

            AssemblyPart wep;
            if (!AssemblyPartManager.I.AllAssemblyParts.TryGetValue(block.SlimBlock, out wep) || wep.ConnectedParts == null)
                return Array.Empty<MyEntity>();

            List<MyEntity> parts = new List<MyEntity>();
            if (useCached)
            {
                foreach (var part in wep.ConnectedParts)
                    if (part.Block.FatBlock != null)
                        parts.Add((MyEntity)part.Block.FatBlock);
            }
            else
            {
                foreach (var part in wep.GetValidNeighbors(true))
                    if (part.FatBlock != null)
                        parts.Add((MyEntity)part.FatBlock);
            }

            return parts.ToArray();
        }

        private MyEntity GetBasePart(int assemblyId)
        {
            PhysicalAssembly wep;
            if (!AssemblyPartManager.I.AllPhysicalAssemblies.TryGetValue(assemblyId, out wep))
                return null;

            return null;  //wep.basePart?.block?.FatBlock as MyEntity;
        }

        private int GetContainingAssembly(MyEntity blockEntity)
        {
            IMySlimBlock block = blockEntity as IMySlimBlock;
            foreach (var partKvp in AssemblyPartManager.I.AllAssemblyParts)
            {
                if (partKvp.Value != block)
                    continue;
                return partKvp.Value.MemberAssembly.AssemblyId;
            }
            return -1;
        }

        private IMyCubeGrid GetAssemblyGrid(int assemblyId)
        {
            PhysicalAssembly wep;
            if (!AssemblyPartManager.I.AllPhysicalAssemblies.TryGetValue(assemblyId, out wep))
                return null;

            return wep.ComponentParts[0].Block.CubeGrid;
        }

        private void AddOnAssemblyClose(Action<int> action)
        {
            AssemblyPartManager.I.OnAssemblyClose += action;
        }

        private void RemoveOnAssemblyClose(Action<int> action)
        {
            AssemblyPartManager.I.OnAssemblyClose -= action;
        }
    }
}
﻿using Sandbox.ModAPI;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using VRage.Game.Components;
using VRage.Utils;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts.Definitions
{
    [MySessionComponentDescriptor(MyUpdateOrder.NoUpdate, Priority = 0)]
    internal class ApiHandler : MySessionComponentBase
    {
        private const long Channel = 8774;
        private Dictionary<string, Delegate> _apiDefinitions = new ApiDefinitions().ModApiMethods;

        /// <summary>
        /// Is the API ready?
        /// </summary>
        public bool IsReady { get; private set; }

        private void HandleMessage(object o)
        {
            if ((o as string) == "ApiEndpointRequest")
            {
                MyAPIGateway.Utilities.SendModMessage(Channel, _apiDefinitions);
                MyLog.Default.WriteLineAndConsole("ModularAssemblies: ModularDefinitionsAPI start load.");
            }
            else
                MyLog.Default.WriteLineAndConsole($"ModularAssemblies: ModularDefinitionsAPI ignored message {o as string}.");
        }

        /// <summary>
        /// Registers for API requests and updates any pre-existing clients.
        /// </summary>
        public override void LoadData()
        {
            // Should not run on clients.
            //if (!MyAPIGateway.Multiplayer.IsServer)
            //    return;
            MyAPIGateway.Utilities.RegisterMessageHandler(Channel, HandleMessage);

            IsReady = true;
            try
            {
                MyAPIGateway.Utilities.SendModMessage(Channel, _apiDefinitions);
            }
            catch (Exception ex)
            {
                MyLog.Default.WriteLineAndConsole($"Exception in Api Load: {ex}"); 
            }
            MyLog.Default.WriteLineAndConsole("ModularAssemblies: ModularDefinitionsAPI inited.");
        }


        /// <summary>
        /// Unloads all API endpoints and detaches events.
        /// </summary>
        protected override void UnloadData()
        {
            MyAPIGateway.Utilities.UnregisterMessageHandler(Channel, HandleMessage);

            IsReady = false;
            MyAPIGateway.Utilities.SendModMessage(Channel, new Dictionary<string, Delegate>());

            MyLog.Default.WriteLineAndConsole("ModularAssemblies: ModularDefinitionsAPI unloaded.");
        }
    }
}
﻿using ProtoBuf;
using System;
using System.Collections.Generic;
using VRageMath;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts.Definitions
{
    public class DefinitionDefs
    {
        [ProtoContract]
        public class DefinitionContainer
        {
            [ProtoMember(1)] internal PhysicalDefinition[] PhysicalDefs;
        }

        [ProtoContract]
        public class PhysicalDefinition
        {
            [ProtoMember(1)] public string Name { get; set; }
            [ProtoMember(2)] public string[] AllowedBlocks { get; set; }
            [ProtoMember(3)] public Dictionary<string, Dictionary<Vector3I, string[]>> AllowedConnections { get; set; }
            [ProtoMember(4)] public string BaseBlock { get; set; }
        }

        [ProtoContract]
        public class FunctionCall
        {
            [ProtoMember(1)] public string DefinitionName { get; set; }
            [ProtoMember(2)] public int PhysicalAssemblyId { get; set; }
            [ProtoMember(3)] public ActionType ActionId { get; set; }
            [ProtoMember(4)] public SerializedObjectArray Values { get; set; }

            public enum ActionType
            {
                OnPartAdd,
                OnPartRemove,
                OnPartDestroy,
                GetAllParts,
                GetAllAssemblies,
                GetMemberParts,
                GetConnectedBlocks,
            }
        }

        [ProtoContract]
        public class SerializedObjectArray
        {
            public SerializedObjectArray() { }

            public SerializedObjectArray(params object[] array)
            {
                List<int> intValuesL = new List<int>();
                List<string> stringValuesL = new List<string>();
                List<long> longValuesL = new List<long>();
                List<ulong> ulongValuesL = new List<ulong>();
                List<Vector3D> vectorValuesL = new List<Vector3D>();
                List<float> floatValuesL = new List<float>();
                List<bool> boolValuesL = new List<bool>();
                List<double> doubleValuesL = new List<double>();

                foreach (var value in array)
                {
                    Type type = value.GetType();
                    if (type == typeof(int))
                        intValuesL.Add((int)value);
                    else if (type == typeof(string))
                        stringValuesL.Add((string)value);
                    else if (type == typeof(long))
                        longValuesL.Add((long)value);
                    else if (type == typeof(ulong))
                        ulongValuesL.Add((ulong)value);
                    else if (type == typeof(Vector3D))
                        vectorValuesL.Add((Vector3D)value);
                    else if (type == typeof(float))
                        floatValuesL.Add((float)value);
                    else if (type == typeof(bool))
                        boolValuesL.Add((bool)value);
                    else if (type == typeof(double))
                        doubleValuesL.Add((double)value);
                }

                intValues = intValuesL.ToArray();
                stringValues = stringValuesL.ToArray();
                longValues = longValuesL.ToArray();
                ulongValues = ulongValuesL.ToArray();
                vectorValues = vectorValuesL.ToArray();
                floatValues = floatValuesL.ToArray();
                boolValues = boolValuesL.ToArray();
                doubleValues = doubleValuesL.ToArray();

                //MyLog.Default.WriteLineAndConsole($"ModularDefinitions.DefinitionDefs: {array.Length} values packaged.");
            }

            [ProtoMember(1)] internal int[] intValues = new int[0];
            [ProtoMember(2)] internal string[] stringValues = new string[0];
            [ProtoMember(3)] internal long[] longValues = new long[0];
            [ProtoMember(4)] internal ulong[] ulongValues = new ulong[0];
            [ProtoMember(5)] internal Vector3D[] vectorValues = new Vector3D[0];
            [ProtoMember(6)] internal float[] floatValues = new float[0];
            [ProtoMember(7)] internal bool[] boolValues = new bool[0];
            [ProtoMember(8)] internal double[] doubleValues = new double[0];

            public object[] Values()
            {
                List<object> values = new List<object>();

                foreach (var value in intValues)
                    values.Add(value);
                foreach (var value in stringValues)
                    values.Add(value);
                foreach (var value in longValues)
                    values.Add(value);
                foreach (var value in ulongValues)
                    values.Add(value);
                foreach (var value in vectorValues)
                    values.Add(value);
                foreach (var value in floatValues)
                    values.Add(value);
                foreach (var value in boolValues)
                    values.Add(value);
                foreach (var value in doubleValues)
                    values.Add(value);

                //MyLog.Default.WriteLineAndConsole($"ModularDefinitions.DefinitionDefs: {values.Count} values recieved.");
                return values.ToArray();
            }
        }
    }
}
﻿using Sandbox.Definitions;
using Sandbox.ModAPI;
using System;
using System.Collections.Generic;
using System.Linq;
using VRage;
using VRage.Game.Components;
using VRage.Profiler;
using VRage.Utils;
using static Modular_Assemblies.Data.Scripts.AssemblyScripts.Definitions.DefinitionDefs;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts.Definitions
{
    /// <summary>
    /// Handles all communication about definitions.
    /// </summary>
    internal class DefinitionHandler
    {
        public static DefinitionHandler I;
        const int DefinitionMessageId = 8772;
        const int InboundMessageId = 8773;
        const int OutboundMessageId = 8771;

        public List<ModularDefinition> ModularDefinitions = new List<ModularDefinition>();

        public void Init()
        {
            I = this;

            MyLog.Default.WriteLineAndConsole("Modular Assemblies: DefinitionHandler loading...");

            MyAPIGateway.Utilities.RegisterMessageHandler(DefinitionMessageId, DefMessageHandler);
            MyAPIGateway.Utilities.RegisterMessageHandler(InboundMessageId, ActionMessageHandler);
            MyAPIGateway.Utilities.SendModMessage(OutboundMessageId, true);

            MyAPIGateway.Session.OnSessionReady += CheckValidDefinitions;
            MyLog.Default.WriteLineAndConsole("Modular Assemblies: Init DefinitionHandler.cs");
        }

        public void Unload()
        {
            I = null;

            MyLog.Default.WriteLineAndConsole("Modular Assemblies: DefinitionHandler closing...");

            MyAPIGateway.Utilities.UnregisterMessageHandler(DefinitionMessageId, DefMessageHandler);
            MyAPIGateway.Utilities.UnregisterMessageHandler(InboundMessageId, ActionMessageHandler);
        }

        public void DefMessageHandler(object o)
        {
            try
            {
                byte[] message = o as byte[];

                if (message == null)
                    return;

                DefinitionContainer baseDefArray = null;
                try
                {
                    baseDefArray = MyAPIGateway.Utilities.SerializeFromBinary<DefinitionContainer>(message);
                }
                catch
                {
                    // ignored
                }

                if (baseDefArray != null)
                {
                    MyLog.Default.WriteLineAndConsole($"ModularAssemblies: Received {baseDefArray.PhysicalDefs.Length} definitions.");
                    foreach (var def in baseDefArray.PhysicalDefs)
                    {
                        var modDef = ModularDefinition.Load(def);
                        if (modDef == null)
                            continue;

                        bool isDefinitionValid = true;
                        // Check for duplicates
                        foreach (var definition in ModularDefinitions)
                        {
                            if (definition.Name != modDef.Name)
                                continue;

                            MyLog.Default.WriteLineAndConsole($"ModularAssemblies: Duplicate DefinitionName in definition {modDef.Name}! Skipping load...");
                            MyAPIGateway.Utilities.ShowMessage("ModularAssemblies", $"Duplicate DefinitionName in definition {modDef.Name}! Skipping load...");
                            isDefinitionValid = false;
                        }
                        if (isDefinitionValid)
                            ModularDefinitions.Add(modDef);
                    }
                }
                else
                {
                    MyLog.Default.WriteLineAndConsole($"ModularAssemblies: Invalid definition container!");
                }
            }
            catch (Exception ex) { MyLog.Default.WriteLineAndConsole($"ModularAssemblies: Exception in DefinitionMessageHandler: {ex}"); }
        }

        public void ActionMessageHandler(object o)
        {
            try
            {
                var message = o as byte[];
                if (message == null) return;

                FunctionCall functionCall = null;
                try
                {
                    functionCall = MyAPIGateway.Utilities.SerializeFromBinary<FunctionCall>(message);
                }
                catch { }

                if (functionCall != null)
                {
                    //MyLog.Default.WriteLineAndConsole($"ModularAssemblies: Recieved action of type {functionCall.ActionId}.");

                    PhysicalAssembly wep = AssemblyPartManager.I.AllPhysicalAssemblies[functionCall.PhysicalAssemblyId];
                    if (wep == null)
                    {
                        MyLog.Default.WriteLineAndConsole($"ModularAssemblies: Invalid PhysicalAssembly!");
                        return;
                    }

                    // TODO: Remove
                    //object[] Values = functionCall.Values.Values();

                    switch (functionCall.ActionId)
                    {
                        default:
                            // Fill in here if necessary.
                            break;
                    }
                }
                else
                {
                    MyLog.Default.WriteLineAndConsole($"ModularAssemblies: functionCall null!");
                }
            }
            catch (Exception ex) { MyLog.Default.WriteLineAndConsole($"ModularAssemblies: Exception in ActionMessageHandler: {ex}"); }
        }

        public void SendOnPartAdd(string DefinitionName, int PhysicalAssemblyId, long BlockEntityId, bool IsBaseBlock)
        {
            SerializedObjectArray Values = new SerializedObjectArray
            (
                BlockEntityId,
                IsBaseBlock
            );

            SendFunc(new FunctionCall()
            {
                ActionId = FunctionCall.ActionType.OnPartAdd,
                DefinitionName = DefinitionName,
                PhysicalAssemblyId = PhysicalAssemblyId,
                Values = Values,
            });
        }

        public void SendOnPartRemove(string DefinitionName, int PhysicalAssemblyId, long BlockEntityId, bool IsBaseBlock)
        {
            SerializedObjectArray Values = new SerializedObjectArray
            (
                BlockEntityId,
                IsBaseBlock
            );

            SendFunc(new FunctionCall()
            {
                ActionId = FunctionCall.ActionType.OnPartRemove,
                DefinitionName = DefinitionName,
                PhysicalAssemblyId = PhysicalAssemblyId,
                Values = Values,
            });
        }

        public void SendOnPartDestroy(string DefinitionName, int PhysicalAssemblyId, long BlockEntityId, bool IsBaseBlock)
        {
            SerializedObjectArray Values = new SerializedObjectArray
            (
                BlockEntityId,
                IsBaseBlock
            );

            SendFunc(new FunctionCall()
            {
                ActionId = FunctionCall.ActionType.OnPartDestroy,
                DefinitionName = DefinitionName,
                PhysicalAssemblyId = PhysicalAssemblyId,
                Values = Values,
            });
        }

        private void SendFunc(FunctionCall call)
        {
            MyAPIGateway.Utilities.SendModMessage(OutboundMessageId, MyAPIGateway.Utilities.SerializeToBinary(call));
            //MyLog.Default.WriteLineAndConsole($"ModularAssemblies: Sending function call [id {call.ActionId}] to [{call.DefinitionName}].");
        }

        private void CheckValidDefinitions()
        {
            // Get all block definition subtypes
            var defs = MyDefinitionManager.Static.GetAllDefinitions();
            List<string> validSubtypes = new List<string>();
            foreach (var def in defs)
            {
                var blockDef = def as MyCubeBlockDefinition;

                if (blockDef != null)
                {
                    validSubtypes.Add(def.Id.SubtypeName);
                }
            }
            foreach (var def in ModularDefinitions.ToList())
                CheckDefinitionValid(def, validSubtypes);
        }

        private void CheckDefinitionValid(ModularDefinition modDef, List<string> validSubtypes)
        {
            foreach (var subtypeId in modDef.AllowedBlocks)
            {
                if (!validSubtypes.Contains(subtypeId))
                {
                    MyLog.Default.WriteLineAndConsole($"ModularAssemblies: Invalid SubtypeId [{subtypeId}] in definition {modDef.Name}! Unexpected behavior may occur.");
                    MyAPIGateway.Utilities.ShowMessage("ModularAssemblies", $"Invalid SubtypeId [{subtypeId}] in definition {modDef.Name}! Unexpected behavior may occur.");
                }
            }
        }
    }
}
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETFramework,Version=v4.8", FrameworkDisplayName = ".NET Framework 4.8")]
