using System;
using System.Diagnostics;
using Modular_Assemblies.Data.Scripts.AssemblyScripts.DebugUtils;
using Modular_Assemblies.Data.Scripts.AssemblyScripts.Definitions;
using VRage.Game.Components;
using VRageMath;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts
{
    [MySessionComponentDescriptor(MyUpdateOrder.AfterSimulation)]
    public class AssembliesSessionInit : MySessionComponentBase
    {
        public static readonly Vector2I ModVersion = new Vector2I(1, 1); // Mod version, API version

        public static AssembliesSessionInit I;
        public static bool DebugMode = false;
        public static bool IsSessionInited;
        private readonly AssemblyPartManager AssemblyPartManager = new AssemblyPartManager();
        private readonly DefinitionHandler DefinitionHandler = new DefinitionHandler();
        public Random Random = new Random();

        #region Base Methods

        public override void LoadData()
        {
            var watch = Stopwatch.StartNew();
            IsSessionInited = false;

            I = this;
            ModularLog.Init();

            AssemblyPartManager.Init();
            DefinitionHandler.Init();

            CommandHandler.Init();

            watch.Stop();
            ModularLog.Log($"Fully initialized in {watch.ElapsedMilliseconds}ms.");
        }

        public override void UpdateAfterSimulation()
        {
            try
            {
                IsSessionInited = true;
                AssemblyPartManager.UpdateAfterSimulation();
            }
            catch (Exception e)
            {
                ModularLog.Log("Handled exception in Modular Assemblies!\n" + e);
            }
        }

        protected override void UnloadData()
        {
            var watch = Stopwatch.StartNew();

            ModularLog.Log("=================================\n          Unload started...\n");

            CommandHandler.Close();

            AssemblyPartManager.Unload();
            DefinitionHandler.Unload();

            I = null;
            watch.Stop();
            ModularLog.Log($"Finished unloading in {watch.ElapsedMilliseconds}ms.");
            ModularLog.Close();
        }

        #endregion
    }
}﻿using System;
using System.Collections.Generic;
using Modular_Assemblies.Data.Scripts.AssemblyScripts.DebugDraw;
using Modular_Assemblies.Data.Scripts.AssemblyScripts.DebugUtils;
using Sandbox.ModAPI;
using VRage.Game.ModAPI;
using VRageMath;
using static Modular_Assemblies.Data.Scripts.AssemblyScripts.Definitions.DefinitionDefs;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts
{
    public class ModularDefinition
    {
        public string[] AllowedBlocks;

        public Dictionary<string, Dictionary<Vector3I, string[]>> AllowedConnections;

        public string BaseBlockSubtype;
        public string Name;

        public Action<int, IMyCubeBlock, bool> OnPartAdd;
        public Action<int, IMyCubeBlock, bool> OnPartDestroy;
        public Action<int, IMyCubeBlock, bool> OnPartRemove;


        public static ModularDefinition Load(ModularPhysicalDefinition definition)
        {
            var def = new ModularDefinition
            {
                AllowedBlocks = definition.AllowedBlockSubtypes,
                AllowedConnections = definition.AllowedConnections ?? new Dictionary<string, Dictionary<Vector3I, string[]>>(),
                BaseBlockSubtype = definition.BaseBlockSubtype,
                Name = definition.Name
            };

            if (def.AllowedBlocks == null || string.IsNullOrEmpty(def.Name))
            {
                string msg = $"Failed to create new ModularDefinition for {definition.Name}!";
                if (def.AllowedBlocks == null)
                    msg += "\nAllowedBlocks is null or empty!";
                if (string.IsNullOrEmpty(def.Name))
                    msg += "\nName is null or empty!";

                ModularLog.Log(msg);
                MyAPIGateway.Utilities.ShowMessage("Modular Assemblies",
                    msg);
                return null;
            }

            ModularLog.Log("Created new ModularDefinition for " + definition.Name);
            return def;
        }

        public bool DoesBlockConnect(IMySlimBlock block, IMySlimBlock adajent, bool lineCheck = true)
        {
            // Check if adjacent block connects first, but don't make an infinite loop
            if (lineCheck)
                if (!DoesBlockConnect(adajent, block, false))
                    return false;

            // Get local offset for below
            Matrix localOrientation;
            block.Orientation.GetMatrix(out localOrientation);

            Dictionary<Vector3I, string[]> connection;
            if (AllowedConnections.TryGetValue(block.BlockDefinition.Id.SubtypeName, out connection))
            {
                foreach (var allowedPosKvp in connection)
                {
                    var offsetAllowedPos =
                        (Vector3I)Vector3D.Rotate(allowedPosKvp.Key, localOrientation) + block.Position;

                    // If list is empty OR block is not in whitelist, continue.
                    if (allowedPosKvp.Value?.Length == 0 ||
                        !(allowedPosKvp.Value?.Contains(adajent.BlockDefinition.Id.SubtypeName) ?? true))
                    {
                        if (AssembliesSessionInit.DebugMode)
                            DebugDrawManager.AddGridPoint(offsetAllowedPos, block.CubeGrid, Color.Red, 3);
                        continue;
                    }

                    if (offsetAllowedPos.IsInsideInclusiveEnd(adajent.Min, adajent.Max))
                    {
                        if (AssembliesSessionInit.DebugMode)
                            DebugDrawManager.AddGridPoint(offsetAllowedPos, block.CubeGrid, Color.Green, 3);
                        return true;
                    }

                    if (AssembliesSessionInit.DebugMode)
                        DebugDrawManager.AddGridPoint(offsetAllowedPos, block.CubeGrid, Color.Red, 3);
                }

                return false;
            }

            // Return true by default.
            return true;
        }

        public bool IsTypeAllowed(string type)
        {
            return AllowedBlocks.Contains(type);
        }

        public bool IsBlockAllowed(IMySlimBlock block)
        {
            return IsTypeAllowed(block.BlockDefinition.Id.SubtypeName);
        }
    }
}﻿using System.Collections.Generic;
using System.Linq;
using Sandbox.ModAPI;
using VRage.Game.ModAPI;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts
{
    /// <summary>
    ///     Attached to every part in a AssemblyDefinition.
    /// </summary>
    public class AssemblyPart
    {
        private PhysicalAssembly _memberAssembly;
        public ModularDefinition AssemblyDefinition;
        public IMySlimBlock Block;

        public HashSet<AssemblyPart> ConnectedParts = new HashSet<AssemblyPart>();
        public bool IsBaseBlock;

        public int PrevAssemblyId = -1;

        public AssemblyPart(IMySlimBlock block, ModularDefinition AssemblyDefinition)
        {
            Block = block;
            this.AssemblyDefinition = AssemblyDefinition;

            IsBaseBlock = AssemblyDefinition.BaseBlockSubtype == Block.BlockDefinition.Id.SubtypeName;

            if (AssemblyPartManager.I.AllAssemblyParts[AssemblyDefinition].ContainsKey(block))
                return;

            AssemblyPartManager.I.AllAssemblyParts[AssemblyDefinition].Add(block, this);

            AssemblyPartManager.I.QueueConnectionCheck(this);
        }

        public PhysicalAssembly MemberAssembly
        {
            get { return _memberAssembly; }
            set
            {
                if (value != _memberAssembly)
                {
                    if (!_memberAssembly?.IsClosing ?? false)
                        _memberAssembly.RemovePart(this);
                    _memberAssembly = value;
                }
            }
        }

        public void DoConnectionCheck(bool cascadingUpdate = false, HashSet<AssemblyPart> visited = null)
        {
            if (visited == null)
                visited = new HashSet<AssemblyPart>();

            if (!visited.Add(this))
                return;

            ConnectedParts = GetValidNeighborParts();

            // If no neighbors AND (is base block OR base block not defined), create assembly.
            if (ConnectedParts.Count == 0 && (AssemblyDefinition.BaseBlockSubtype == null || IsBaseBlock))
            {
                _memberAssembly = new PhysicalAssembly(AssemblyPartManager.I.CreatedPhysicalAssemblies, this,
                    AssemblyDefinition);
                // Trigger cascading update
                if (IsBaseBlock || cascadingUpdate)
                {
                    MyAPIGateway.Utilities.ShowNotification("" + GetValidNeighborParts().Count);
                    foreach (var neighbor in GetValidNeighborParts())
                        if (neighbor.MemberAssembly == null)
                            neighbor.DoConnectionCheck(true);
                }

                return;
            }

            var assemblies = new HashSet<PhysicalAssembly>();
            foreach (var neighbor in ConnectedParts)
            {
                if (neighbor.MemberAssembly != null) assemblies.Add(neighbor.MemberAssembly);
                neighbor.ConnectedParts = neighbor.GetValidNeighborParts();
            }

            // Double-checking for null assemblies
            if (assemblies.Count == 0 && (AssemblyDefinition.BaseBlockSubtype == null || IsBaseBlock))
            {
                _memberAssembly = new PhysicalAssembly(AssemblyPartManager.I.CreatedPhysicalAssemblies, this,
                    AssemblyDefinition);
                // Trigger cascading update
                if (IsBaseBlock || cascadingUpdate)
                {
                    MyAPIGateway.Utilities.ShowNotification("" + GetValidNeighborParts().Count);
                    foreach (var neighbor in GetValidNeighborParts())
                        if (neighbor.MemberAssembly == null)
                            neighbor.DoConnectionCheck(true);
                }

                return;
            }

            var largestAssembly = MemberAssembly;
            foreach (var assembly in assemblies)
                if (assembly.ComponentParts.Length > (largestAssembly?.ComponentParts.Length ?? -1))
                {
                    largestAssembly?.MergeWith(assembly);
                    largestAssembly = assembly;
                }
                else
                {
                    assembly.MergeWith(largestAssembly);
                }

            largestAssembly?.AddPart(this);

            // Trigger cascading update
            if (IsBaseBlock || cascadingUpdate)
                //debug notification begone
                //MyAPIGateway.Utilities.ShowNotification("" + GetValidNeighborParts().Count);
                foreach (var neighbor in GetValidNeighborParts())
                    if (neighbor.MemberAssembly == null)
                        neighbor.DoConnectionCheck(true, visited);
        }

        public void PartRemoved(bool notifyMods = true)
        {
            var assemblyId = MemberAssembly?.AssemblyId ?? -1;
            MemberAssembly?.RemovePart(this);
            foreach (var neighbor in ConnectedParts)
                neighbor.ConnectedParts.Remove(this);

            if (notifyMods)
            {
                AssemblyDefinition.OnPartRemove?.Invoke(assemblyId, Block.FatBlock, IsBaseBlock);
                if (Block.Integrity <= 0)
                    AssemblyDefinition.OnPartDestroy?.Invoke(assemblyId, Block.FatBlock, IsBaseBlock);
            }
        }

        /// <summary>
        ///     Returns attached (as per AssemblyPart) neighbor blocks.
        /// </summary>
        /// <returns></returns>
        public List<IMySlimBlock> GetValidNeighbors(bool MustShareAssembly = false)
        {
            var neighbors = new List<IMySlimBlock>();
            Block.GetNeighbours(neighbors);

            neighbors.RemoveAll(nBlock => !AssemblyDefinition.DoesBlockConnect(Block, nBlock));

            if (MustShareAssembly)
                neighbors.RemoveAll(nBlock =>
                {
                    AssemblyPart part;
                    if (!AssemblyPartManager.I.AllAssemblyParts[AssemblyDefinition].TryGetValue(nBlock, out part))
                        return true;
                    return part.MemberAssembly != MemberAssembly;
                });

            return neighbors;
        }

        /// <summary>
        ///     Returns attached (as per AssemblyPart) neighbor blocks's parts.
        /// </summary>
        /// <returns></returns>
        public HashSet<AssemblyPart> GetValidNeighborParts(bool MustShareAssembly = false)
        {
            var validNeighbors = new List<AssemblyPart>();
            foreach (var nBlock in GetValidNeighbors())
            {
                AssemblyPart nBlockPart;
                if (!AssemblyPartManager.I.AllAssemblyParts[AssemblyDefinition].TryGetValue(nBlock, out nBlockPart))
                    continue;

                if (!MustShareAssembly || nBlockPart.MemberAssembly == MemberAssembly)
                    validNeighbors.Add(nBlockPart);
            }

            return validNeighbors.ToHashSet();
        }

        public void GetAllConnectedParts(ref HashSet<AssemblyPart> connectedParts)
        {
            // If a block has already been added, return.
            if (!connectedParts.Add(this))
                return;
            foreach (var part in ConnectedParts) part.GetAllConnectedParts(ref connectedParts);
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Linq;
using Modular_Assemblies.Data.Scripts.AssemblyScripts.DebugUtils;
using Modular_Assemblies.Data.Scripts.AssemblyScripts.Definitions;
using Sandbox.ModAPI;
using VRage.Game.ModAPI;
using VRage.ModAPI;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts
{
    /// <summary>
    ///     Creates and manages all AssemblyParts and PhysicalAssemblies.
    /// </summary>
    public class AssemblyPartManager
    {
        public static AssemblyPartManager I;

        /// <summary>
        ///     Every single AssemblyPart in the world, mapped to definitions.
        /// </summary>
        public Dictionary<ModularDefinition, Dictionary<IMySlimBlock, AssemblyPart>> AllAssemblyParts =
            new Dictionary<ModularDefinition, Dictionary<IMySlimBlock, AssemblyPart>>();

        /// <summary>
        ///     Every single PhysicalAssembly in the world.
        /// </summary>
        public Dictionary<int, PhysicalAssembly> AllPhysicalAssemblies = new Dictionary<int, PhysicalAssembly>();

        public int CreatedPhysicalAssemblies = 0;

        public Action<int> OnAssemblyClose;

        private readonly HashSet<IMySlimBlock> QueuedBlockAdds = new HashSet<IMySlimBlock>();
        private readonly HashSet<AssemblyPart> QueuedConnectionChecks = new HashSet<AssemblyPart>();

        public void QueueBlockAdd(IMySlimBlock block)
        {
            QueuedBlockAdds.Add(block);
        }

        public void QueueConnectionCheck(AssemblyPart part)
        {
            QueuedConnectionChecks.Add(part);
        }

        public void Init()
        {
            ModularLog.Log("AssemblyPartManager loading...");

            I = this;

            MyAPIGateway.Entities.OnEntityAdd += OnGridAdd;
            MyAPIGateway.Entities.OnEntityRemove += OnGridRemove;
        }

        public void Unload()
        {
            I = null; // important for avoiding this object to remain allocated in memory
            AllAssemblyParts.Clear();
            AllPhysicalAssemblies.Clear();
            OnAssemblyClose = null;

            ModularLog.Log("AssemblyPartManager closing...");

            MyAPIGateway.Entities.OnEntityAdd -= OnGridAdd;
            MyAPIGateway.Entities.OnEntityRemove -= OnGridRemove;
        }

        public void UpdateAfterSimulation()
        {
            // Queue gridadds to account for world load/grid pasting
            ProcessQueuedBlockAdds();
            // Queue partadds to account for world load/grid pasting
            ProcessQueuedConnectionChecks();

            foreach (var assembly in AllPhysicalAssemblies.Values) assembly.Update();

            if (AssembliesSessionInit.DebugMode)
            {
                var partCount = 0;
                foreach (var definition in AllAssemblyParts)
                    partCount += definition.Value.Count;
                MyAPIGateway.Utilities.ShowNotification(
                    $"Assemblies: {AllPhysicalAssemblies.Count} | Parts: {partCount}", 1000 / 60);
                MyAPIGateway.Utilities.ShowNotification($"Definitions: {DefinitionHandler.I.ModularDefinitions.Count}",
                    1000 / 60);
            }
        }

        private void ProcessQueuedBlockAdds()
        {
            HashSet<IMySlimBlock> queuedBlocks;
            lock (QueuedBlockAdds)
            {
                queuedBlocks = QueuedBlockAdds.ToHashSet();
                QueuedBlockAdds.Clear();
            }

            foreach (var queuedBlock in queuedBlocks) OnBlockAdd(queuedBlock);
        }

        private void ProcessQueuedConnectionChecks()
        {
            HashSet<AssemblyPart> queuedParts;
            lock (QueuedConnectionChecks)
            {
                queuedParts = new HashSet<AssemblyPart>(QueuedConnectionChecks);
                QueuedConnectionChecks.Clear();
            }

            foreach (var queuedPart in queuedParts) queuedPart.DoConnectionCheck();
        }

        private void OnGridAdd(IMyEntity entity)
        {
            if (!(entity is IMyCubeGrid))
                return;

            var grid = (IMyCubeGrid)entity;

            // Exclude projected and held grids
            if (grid.Physics == null)
                return;

            grid.OnBlockAdded += OnBlockAdd;
            grid.OnBlockRemoved += OnBlockRemove;

            var existingBlocks = new List<IMySlimBlock>();
            grid.GetBlocks(existingBlocks);
            foreach (var block in existingBlocks)
                QueueBlockAdd(block);
        }

        private void OnBlockAdd(IMySlimBlock block)
        {
            if (block == null)
                return;
            try
            {
                foreach (var modularDefinition in DefinitionHandler.I.ModularDefinitions)
                {
                    if (!modularDefinition.IsBlockAllowed(block))
                        continue;

                    var w = new AssemblyPart(block, modularDefinition);
                    // No further init work is needed.
                    // Not returning because a part can have multiple assemblies.
                }
            }
            catch (Exception e)
            {
                ModularLog.Log("Handled exception in AssemblyPartManager.OnBlockAdd()!\n" + e);
            }
        }

        private void OnGridRemove(IMyEntity entity)
        {
            if (!(entity is IMyCubeGrid))
                return;

            var grid = (IMyCubeGrid)entity;

            // Exclude projected and held grids
            if (grid.Physics == null)
                return;

            grid.OnBlockAdded -= OnBlockAdd;
            grid.OnBlockRemoved -= OnBlockRemove;

            var toRemove = new List<AssemblyPart>();
            var toRemoveAssemblies = new HashSet<PhysicalAssembly>();
            foreach (var definitionPartSet in AllAssemblyParts.Values)
            {
                foreach (var partKvp in definitionPartSet)
                {
                    if (partKvp.Key.CubeGrid != grid)
                        continue;

                    toRemove.Add(partKvp.Value);
                    if (partKvp.Value.MemberAssembly != null)
                        toRemoveAssemblies.Add(partKvp.Value.MemberAssembly);
                }
            }
            

            foreach (var deadAssembly in toRemoveAssemblies)
                deadAssembly.Close();
            foreach (var deadPart in toRemove)
                AllAssemblyParts[deadPart.AssemblyDefinition].Remove(deadPart.Block);
        }

        private void OnBlockRemove(IMySlimBlock block)
        {
            if (block == null)
                return;
            AssemblyPart part;
            foreach (var definitionPartSet in AllAssemblyParts.Values)
            {
                if (definitionPartSet.TryGetValue(block, out part))
                {
                    part.PartRemoved();
                    AllAssemblyParts[part.AssemblyDefinition].Remove(block);
                }
            }
        }

        /// <summary>
        ///     Assigns all valid existing blocks an assembly part. Very slow operation, use sparingly.
        /// </summary>
        /// <param name="definition"></param>
        public void RegisterExistingBlocks(ModularDefinition definition)
        {
            if (definition == null)
                return;

            // Iterate through all entities and pick out grids
            var allEntities = new HashSet<IMyEntity>();
            MyAPIGateway.Entities.GetEntities(allEntities, entity => entity is IMyCubeGrid);

            // Parallel iterate through all grids and check all blocks for definition
            MyAPIGateway.Parallel.ForEach(allEntities, entity =>
            {
                foreach (var block in ((IMyCubeGrid)entity).GetFatBlocks<IMyCubeBlock>())
                    if (definition.AllowedBlocks.Contains(block.BlockDefinition.SubtypeId))
                    {
                        var w = new AssemblyPart(block.SlimBlock, definition);
                    }
            });
        }
    }
}﻿using System;
using System.Collections.Generic;
using Modular_Assemblies.Data.Scripts.AssemblyScripts.DebugDraw;
using Modular_Assemblies.Data.Scripts.AssemblyScripts.DebugUtils;
using Sandbox.ModAPI;
using VRageMath;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts
{
    /// <summary>
    ///     The collection of AssemblyParts attached to a modular assembly base.
    /// </summary>
    public class PhysicalAssembly
    {
        public ModularDefinition AssemblyDefinition;
        public int AssemblyId = -1;
        public AssemblyPart BasePart;

        private readonly Color color;
        private List<AssemblyPart> _componentParts = new List<AssemblyPart>();
        public AssemblyPart[] ComponentParts => _componentParts.ToArray();
        public bool IsClosing;

        public PhysicalAssembly(int id, AssemblyPart basePart, ModularDefinition AssemblyDefinition)
        {
            if (AssemblyDefinition.BaseBlockSubtype != null)
                BasePart = basePart;
            this.AssemblyDefinition = AssemblyDefinition;
            AssemblyId = id;
            AssemblyPartManager.I.CreatedPhysicalAssemblies++;

            if (AssemblyPartManager.I.AllPhysicalAssemblies.ContainsKey(id))
                throw new Exception("Duplicate assembly ID!");
            AssemblyPartManager.I.AllPhysicalAssemblies.Add(id, this);


            color = new Color(AssembliesSessionInit.I.Random.Next(255), AssembliesSessionInit.I.Random.Next(255),
                AssembliesSessionInit.I.Random.Next(255));

            AddPart(basePart);
        }

        public void Update()
        {
            if (AssembliesSessionInit.DebugMode)
                foreach (var part in _componentParts)
                {
                    DebugDrawManager.AddGridPoint(part.Block.Position, part.Block.CubeGrid, color, 0f);
                    foreach (var conPart in part.ConnectedParts)
                        DebugDrawManager.AddLine(
                            DebugDrawManager.GridToGlobal(part.Block.Position, part.Block.CubeGrid),
                            DebugDrawManager.GridToGlobal(conPart.Block.Position, part.Block.CubeGrid), color, 0f);
                }
        }

        public void AddPart(AssemblyPart part)
        {
            if (_componentParts.Contains(part) || part.Block == null)
                return;

            _componentParts.Add(part);
            part.MemberAssembly = this;
            if (part.PrevAssemblyId != AssemblyId)
                part.AssemblyDefinition.OnPartAdd?.Invoke(AssemblyId, part.Block.FatBlock, part.IsBaseBlock);
            part.PrevAssemblyId = AssemblyId;
        }

        public void RemovePart(AssemblyPart part)
        {
            if (!_componentParts.Remove(part))
                return;

            var neighbors = part.ConnectedParts;

            foreach (var neighbor in neighbors) neighbor.ConnectedParts = neighbor.GetValidNeighborParts();

            if (_componentParts.Count == 0 || part == BasePart)
            {
                Close();
                return;
            }

            if (neighbors.Count == 1)
                return;

            var partLoops = new List<HashSet<AssemblyPart>>();
            foreach (var neighbor in neighbors)
            {
                var connectedParts = new HashSet<AssemblyPart>();
                neighbor.GetAllConnectedParts(ref connectedParts);

                partLoops.Add(connectedParts);
            }

            if (partLoops.Count <= 1)
                return;

            // Split apart, keeping this assembly as the largest loop.
            var largestLoop = partLoops[0];
            foreach (var loop in partLoops)
                if (loop.Count > largestLoop.Count)
                    largestLoop = loop;
            foreach (var componentPart in _componentParts.ToArray())
            {
                if (!largestLoop.Contains(componentPart))
                {
                    RemovePart(componentPart);
                }
            }
        }

        public void Close()
        {
            IsClosing = true;
            AssemblyPartManager.I.OnAssemblyClose?.Invoke(AssemblyId);
            if (_componentParts != null)
                foreach (var part in _componentParts)
                {
                    //nullcheck for good luck :^)
                    if (part?.MemberAssembly != this)
                        continue;

                    part.MemberAssembly = null;
                    part.ConnectedParts.Clear();
                }

            _componentParts = null;
            //basePart = null;
            AssemblyPartManager.I.AllPhysicalAssemblies.Remove(AssemblyId);
        }


        public void MergeWith(PhysicalAssembly assembly)
        {
            if (assembly == null || assembly == this)
                return;

            foreach (var part in _componentParts.ToArray()) assembly.AddPart(part);
            Close();
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Text;
using Modular_Assemblies.Data.Scripts.AssemblyScripts.DebugUtils;
using Sandbox.ModAPI;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts
{
    /// <summary>
    ///     Parses commands from chat and triggers relevant methods.
    /// </summary>
    public class CommandHandler
    {
        public static CommandHandler I;

        private readonly Dictionary<string, Command> _commands = new Dictionary<string, Command>
        {
            ["help"] = new Command(
                "Modular Assemblies",
                "Displays command help.",
                message => I.ShowHelp()),
            ["debug"] = new Command(
                "Modular Assemblies",
                "Toggles debug draw.",
                message => AssembliesSessionInit.DebugMode = !AssembliesSessionInit.DebugMode)
        };

        private CommandHandler()
        {
        }

        private void ShowHelp()
        {
            var helpBuilder = new StringBuilder();
            var modNames = new List<string>();
            foreach (var command in _commands.Values)
                if (!modNames.Contains(command.modName))
                    modNames.Add(command.modName);

            MyAPIGateway.Utilities.ShowMessage("Modular Assemblies Help", "");

            foreach (var modName in modNames)
            {
                foreach (var command in _commands)
                    if (command.Value.modName == modName)
                        helpBuilder.Append($"\n{{!md {command.Key}}}: " + command.Value.helpText);

                MyAPIGateway.Utilities.ShowMessage($"[{modName}]", helpBuilder + "\n");
                helpBuilder.Clear();
            }
        }

        public static void Init()
        {
            Close(); // Close existing command handlers.
            I = new CommandHandler();
            MyAPIGateway.Utilities.MessageEnteredSender += I.Command_MessageEnteredSender;
            MyAPIGateway.Utilities.ShowMessage($"Modular Assemblies v{AssembliesSessionInit.ModVersion.X}",
                "Chat commands registered - run \"!md help\" for help.");
        }

        public static void Close()
        {
            if (I != null)
            {
                MyAPIGateway.Utilities.MessageEnteredSender -= I.Command_MessageEnteredSender;
                I._commands.Clear();
            }

            I = null;
        }

        private void Command_MessageEnteredSender(ulong sender, string messageText, ref bool sendToOthers)
        {
            try
            {
                // Only register for commands
                if (messageText.Length == 0 || !messageText.ToLower().StartsWith("!md"))
                    return;

                sendToOthers = false;

                var parts = messageText.Substring(4).Trim(' ').Split(' '); // Convert commands to be more parseable

                if (parts[0] == "")
                {
                    ShowHelp();
                    return;
                }

                // Really basic command handler
                if (_commands.ContainsKey(parts[0].ToLower()))
                    _commands[parts[0].ToLower()].action.Invoke(parts);
                else
                    MyAPIGateway.Utilities.ShowMessage("Modular Assemblies",
                        $"Unrecognized command \"{parts[0].ToLower()}\"");
            }
            catch (Exception ex)
            {
                SoftHandle.RaiseException(ex, typeof(CommandHandler));
            }
        }

        /// <summary>
        ///     Registers a command for Modular Assemblies' command handler.
        /// </summary>
        /// <param name="command"></param>
        /// <param name="action"></param>
        /// <param name="modName"></param>
        public static void AddCommand(string command, string helpText, Action<string[]> action,
            string modName = "Modular Assemblies")
        {
            if (I == null)
                return;

            command = command.ToLower();
            if (I._commands.ContainsKey(command))
            {
                SoftHandle.RaiseException("Attempted to add duplicate command " + command + " from [" + modName + "]",
                    callingType: typeof(CommandHandler));
                return;
            }

            I._commands.Add(command, new Command(modName, helpText, action));
            ModularLog.Log($"Registered new chat command \"!{command}\" from [{modName}]");
        }

        /// <summary>
        ///     Removes a command from Modular Assemblies' command handler.
        /// </summary>
        /// <param name="command"></param>
        public static void RemoveCommand(string command)
        {
            command = command.ToLower();
            if (I == null || command == "help" || command == "debug") // Debug and Help should never be removed.
                return;
            if (I._commands.Remove(command))
                ModularLog.Log($"De-registered chat command \"!{command}\".");
        }

        private class Command
        {
            public readonly Action<string[]> action;
            public readonly string helpText;
            public readonly string modName;

            public Command(string modName, string helpText, Action<string[]> action)
            {
                this.modName = modName;
                this.helpText = helpText;
                this.action = action;
            }
        }
    }
}﻿namespace Modular_Assemblies.Data.Scripts.AssemblyScripts.Commands
{
    /// <summary>
    ///     Stores methods for commands in CommandHandler.
    /// </summary>
    internal static class CommandMethods
    {
    }
}﻿using System;
using System.Collections.Generic;
using System.Linq;
using Sandbox.ModAPI;
using VRage;
using VRage.Game;
using VRage.Game.Components;
using VRage.Game.ModAPI;
using VRage.Utils;
using VRageMath;
using static VRageRender.MyBillboard;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts.DebugDraw
{
    [MySessionComponentDescriptor(MyUpdateOrder.BeforeSimulation)]
    public class DebugDrawManager : MySessionComponentBase
    {
        protected const float OnTopColorMul = 0.5f;

        private const float DepthRatioF = 0.01f;
        // i'm gonna kiss digi on the 

        private static DebugDrawManager Instance;
        protected static readonly MyStringId MaterialDot = MyStringId.GetOrCompute("WhiteDot");
        protected static readonly MyStringId MaterialSquare = MyStringId.GetOrCompute("Square");
        private readonly Dictionary<IMyGps, long> QueuedGps = new Dictionary<IMyGps, long>();

        private readonly Dictionary<Vector3I, MyTuple<long, Color, IMyCubeGrid>> QueuedGridPoints =
            new Dictionary<Vector3I, MyTuple<long, Color, IMyCubeGrid>>();

        private readonly Dictionary<MyTuple<Vector3D, Vector3D>, MyTuple<long, Color>> QueuedLinePoints =
            new Dictionary<MyTuple<Vector3D, Vector3D>, MyTuple<long, Color>>();

        private readonly Dictionary<Vector3D, MyTuple<long, Color>> QueuedPoints =
            new Dictionary<Vector3D, MyTuple<long, Color>>();

        public override void LoadData()
        {
            Instance = this;
        }

        protected override void UnloadData()
        {
            Instance = null;
        }

        public static void AddPoint(Vector3D globalPos, Color color, float duration)
        {
            if (Instance == null)
                return;

            if (Instance.QueuedPoints.ContainsKey(globalPos))
                Instance.QueuedPoints[globalPos] =
                    new MyTuple<long, Color>(DateTime.Now.Ticks + (long)(duration * TimeSpan.TicksPerSecond), color);
            else
                Instance.QueuedPoints.Add(globalPos,
                    new MyTuple<long, Color>(DateTime.Now.Ticks + (long)(duration * TimeSpan.TicksPerSecond), color));
        }

        public static void AddGPS(string name, Vector3D position, float duration)
        {
            var gps = MyAPIGateway.Session.GPS.Create(name, string.Empty, position, true, true);
            //gps.DiscardAt = TimeSpan.FromSeconds(duration);
            //MyAPIGateway.Session.GPS.AddLocalGps(gps);
            Instance.QueuedGps.Add(gps, DateTime.Now.Ticks + (long)(duration * TimeSpan.TicksPerSecond));
        }

        public static void AddGridGPS(string name, Vector3I gridPosition, IMyCubeGrid grid, float duration)
        {
            AddGPS(name, GridToGlobal(gridPosition, grid), duration);
        }

        public static void AddGridPoint(Vector3I blockPos, IMyCubeGrid grid, Color color, float duration)
        {
            if (Instance == null)
                return;

            if (Instance.QueuedGridPoints.ContainsKey(blockPos))
                Instance.QueuedGridPoints[blockPos] =
                    new MyTuple<long, Color, IMyCubeGrid>(
                        DateTime.Now.Ticks + (long)(duration * TimeSpan.TicksPerSecond), color, grid);
            else
                Instance.QueuedGridPoints.Add(blockPos,
                    new MyTuple<long, Color, IMyCubeGrid>(
                        DateTime.Now.Ticks + (long)(duration * TimeSpan.TicksPerSecond), color, grid));
        }

        public static void AddLine(Vector3D origin, Vector3D destination, Color color, float duration)
        {
            if (Instance == null)
                return;

            var key = new MyTuple<Vector3D, Vector3D>(origin, destination);
            if (Instance.QueuedLinePoints.ContainsKey(key))
                Instance.QueuedLinePoints[key] =
                    new MyTuple<long, Color>(DateTime.Now.Ticks + (long)(duration * TimeSpan.TicksPerSecond), color);
            else
                Instance.QueuedLinePoints.Add(key,
                    new MyTuple<long, Color>(DateTime.Now.Ticks + (long)(duration * TimeSpan.TicksPerSecond), color));
        }

        public override void Draw()
        {
            base.Draw();

            foreach (var key in QueuedPoints.Keys.ToList())
            {
                DrawPoint0(key, QueuedPoints[key].Item2);

                if (DateTime.Now.Ticks > QueuedPoints[key].Item1)
                    QueuedPoints.Remove(key);
            }

            foreach (var key in QueuedGps.Keys.ToList())
                if (DateTime.Now.Ticks > QueuedGps[key])
                {
                    MyAPIGateway.Session.GPS.RemoveLocalGps(key);
                    QueuedGps.Remove(key);
                }

            foreach (var key in QueuedGridPoints.Keys.ToList())
            {
                DrawGridPoint0(key, QueuedGridPoints[key].Item3, QueuedGridPoints[key].Item2);

                if (DateTime.Now.Ticks > QueuedGridPoints[key].Item1)
                    QueuedGridPoints.Remove(key);
            }

            foreach (var key in QueuedLinePoints.Keys.ToList())
            {
                DrawLine0(key.Item1, key.Item2, QueuedLinePoints[key].Item2);

                if (DateTime.Now.Ticks > QueuedLinePoints[key].Item1)
                    QueuedLinePoints.Remove(key);
            }
        }

        private void DrawPoint0(Vector3D globalPos, Color color)
        {
            //MyTransparentGeometry.AddPointBillboard(MaterialDot, color, globalPos, 1.25f, 0, blendType: BlendTypeEnum.PostPP);
            var depthScale = ToAlwaysOnTop(ref globalPos);
            MyTransparentGeometry.AddPointBillboard(MaterialDot, color * OnTopColorMul, globalPos, 0.5f * depthScale, 0,
                blendType: BlendTypeEnum.PostPP);
        }

        private void DrawGridPoint0(Vector3I blockPos, IMyCubeGrid grid, Color color)
        {
            DrawPoint0(GridToGlobal(blockPos, grid), color);
        }

        private void DrawLine0(Vector3D origin, Vector3D destination, Color color)
        {
            var length = (float)(destination - origin).Length();
            var direction = (destination - origin) / length;

            MyTransparentGeometry.AddLineBillboard(MaterialSquare, color, origin, direction, length, 0.5f,
                BlendTypeEnum.PostPP);

            var depthScale = ToAlwaysOnTop(ref origin);
            direction *= depthScale;

            MyTransparentGeometry.AddLineBillboard(MaterialSquare, color * OnTopColorMul, origin, direction, length,
                0.5f * depthScale, BlendTypeEnum.PostPP);
        }

        public static Vector3D GridToGlobal(Vector3I position, IMyCubeGrid grid)
        {
            return Vector3D.Rotate((Vector3D)position * 2.5f, grid.WorldMatrix) + grid.GetPosition();
        }

        protected static float ToAlwaysOnTop(ref Vector3D position)
        {
            var camMatrix = MyAPIGateway.Session.Camera.WorldMatrix;
            position = camMatrix.Translation + (position - camMatrix.Translation) * DepthRatioF;

            return DepthRatioF;
        }
    }
}﻿using System;
using System.IO;
using Sandbox.ModAPI;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts.DebugUtils
{
    /// <summary>
    ///     Standard logging class. Outputs to %AppData%\Roaming\Space Engineers\Storage\
    /// </summary>
    public class ModularLog
    {
        private static ModularLog I;
        private readonly TextWriter _writer;

        private ModularLog()
        {
            MyAPIGateway.Utilities.DeleteFileInGlobalStorage("ModularAssemblies.log");
            _writer = MyAPIGateway.Utilities
                .WriteFileInGlobalStorage(
                    "ModularAssemblies.log"); // Only creating one debug.log to avoid clutter. Might change in the future.
            _writer.WriteLine(
                $"     Modular Assemblies v{AssembliesSessionInit.ModVersion.X} - Debug Log\n===========================================\n");
            _writer.Flush();
        }

        public static void Log(string message)
        {
            I._Log(message);
        }

        public static void LogException(Exception ex, Type callingType, string prefix = "")
        {
            I._LogException(ex, callingType, prefix);
        }

        public static void Init()
        {
            Close();
            I = new ModularLog();
        }

        public static void Close()
        {
            if (I != null)
            {
                Log("Closing log writer.");
                I._writer.Close();
            }

            I = null;
        }

        private void _Log(string message)
        {
            _writer.WriteLine($"{DateTime.UtcNow:HH:mm:ss}: {message}");
            _writer.Flush();
        }

        private void _LogException(Exception ex, Type callingType, string prefix = "")
        {
            if (ex == null)
            {
                _Log("Null exception! CallingType: " + callingType.FullName);
                return;
            }

            _Log(prefix + $"Exception in {callingType.FullName}! {ex.Message}\n{ex.StackTrace}\n{ex.InnerException}");
        }
    }
}﻿using System;
using Sandbox.ModAPI;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts.DebugUtils
{
    public class SoftHandle
    {
        public static void RaiseException(string message, Exception ex = null, Type callingType = null,
            ulong callerId = ulong.MaxValue)
        {
            if (message == null)
                return;

            if (!MyAPIGateway.Utilities.IsDedicated)
                MyAPIGateway.Utilities.ShowNotification("Minor Exception: " + message);
            var soft = new Exception(message, ex);
            ModularLog.LogException(soft, callingType ?? typeof(SoftHandle),
                callerId != ulong.MaxValue ? $"Shared exception from {callerId}: " : "");
        }

        public static void RaiseException(Exception exception, Type callingType = null, ulong callerId = ulong.MaxValue)
        {
            if (exception == null)
                return;
            if (!MyAPIGateway.Utilities.IsDedicated)
                MyAPIGateway.Utilities.ShowNotification("Minor Exception: " + exception.Message);
            ModularLog.LogException(exception, callingType ?? typeof(SoftHandle),
                callerId != ulong.MaxValue ? $"Shared exception from {callerId}: " : "");
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Linq;
using Modular_Assemblies.Data.Scripts.AssemblyScripts.DebugUtils;
using VRage.Game.ModAPI;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts.Definitions
{
    internal class ApiDefinitions
    {
        internal readonly Dictionary<string, Delegate> ModApiMethods;

        internal ApiDefinitions()
        {
            ModApiMethods = new Dictionary<string, Delegate>
            {
                // Global assembly methods
                ["GetAllParts"] =
                    new Func<IMyCubeBlock[]>(
                        GetAllParts), // Returns a IMyCubeBlock array of all CubeBlocks with Assembly parts.
                ["GetAllAssemblies"] = new Func<int[]>(GetAllAssemblies), // Returns an int array of all Assembly IDs.

                // Per-assembly methods
                ["GetMemberParts"] =
                    new Func<int, IMyCubeBlock[]>(
                        GetMemberParts), // Returns a IMyCubeBlock array of all CubeBlocks within a given Assembly ID.
                ["GetBasePart"] = new Func<int, IMyCubeBlock>(GetBasePart),
                ["GetAssemblyGrid"] =
                    new Func<int, IMyCubeGrid>(
                        GetAssemblyGrid), // Returns the IMyCubeGrid an assembly ID is contained in.
                ["AddOnAssemblyClose"] =
                    new Action<Action<int>>(
                        AddOnAssemblyClose), // Registers an Action<AssemblyId> triggered on assembly removal.
                ["RemoveOnAssemblyClose"] =
                    new Action<Action<int>>(
                        RemoveOnAssemblyClose), // De-registers an Action<AssemblyId> triggered on assembly removal.
                ["RecreateAssembly"] = new Action<int>(RecreateAssembly),

                // Per-part methods
                ["GetConnectedBlocks"] = new Func<IMyCubeBlock, string, bool, IMyCubeBlock[]>(GetConnectedBlocks),
                ["GetContainingAssembly"] = new Func<IMyCubeBlock, string, int>(GetContainingAssembly),
                ["RecreateConnections"] = new Action<IMyCubeBlock, string>(RecreateConnections),

                // Definition methods
                ["RegisterDefinitions"] =
                    new Func<byte[], string[]>(DefinitionHandler.I
                        .RegisterDefinitions), // Tries to register a new definition.
                ["UnregisterDefinition"] =
                    new Func<string, bool>(DefinitionHandler.I
                        .UnregisterDefinition), // Tries to de-register a definition.
                ["GetAllDefinitions"] =
                    new Func<string[]>(() =>
                        DefinitionHandler.I.ModularDefinitionsMap.Keys
                            .ToArray()), // Returns a list of all definition names.
                ["RegisterOnPartAdd"] =
                    new Action<string, Action<int, IMyCubeBlock, bool>>(DefinitionHandler.I.RegisterOnPartAdd),
                ["RegisterOnPartRemove"] =
                    new Action<string, Action<int, IMyCubeBlock, bool>>(DefinitionHandler.I.RegisterOnPartRemove),
                ["RegisterOnPartDestroy"] =
                    new Action<string, Action<int, IMyCubeBlock, bool>>(DefinitionHandler.I.RegisterOnPartDestroy),
                ["UnregisterOnPartAdd"] =
                    new Action<string, Action<int, IMyCubeBlock, bool>>(DefinitionHandler.I.UnregisterOnPartAdd),
                ["UnregisterOnPartRemove"] =
                    new Action<string, Action<int, IMyCubeBlock, bool>>(DefinitionHandler.I.UnregisterOnPartRemove),
                ["UnregisterOnPartDestroy"] =
                    new Action<string, Action<int, IMyCubeBlock, bool>>(DefinitionHandler.I.UnregisterOnPartDestroy),

                // Global methods
                ["IsDebug"] =
                    new Func<bool>(() =>
                        AssembliesSessionInit.DebugMode), // Returns whether debug mode is enabled or not.
                ["LogWriteLine"] =
                    new Action<string>(ModularLog.Log), // Writes a new line in the Modular Assemblies debug log.
                ["AddChatCommand"] =
                    new Action<string, string, Action<string[]>, string>(CommandHandler
                        .AddCommand), // Registers a command for Modular Assemblies' command handler.
                ["RemoveChatCommand"] =
                    new Action<string>(CommandHandler
                        .RemoveCommand) // Removes a command from Modular Assemblies' command handler.
            };
        }

        #region Global Assembly Methods

        private IMyCubeBlock[] GetAllParts()
        {
            var parts = new List<IMyCubeBlock>();
            foreach (var definitionBlockSet in AssemblyPartManager.I.AllAssemblyParts.Values)
            foreach (var block in definitionBlockSet.Keys)
                if (block.FatBlock != null)
                    parts.Add(block.FatBlock);
            return parts.ToArray();
        }

        private int[] GetAllAssemblies()
        {
            return AssemblyPartManager.I.AllPhysicalAssemblies.Keys.ToArray();
        }

        #endregion

        #region Per-Assembly Methods

        private IMyCubeBlock[] GetMemberParts(int assemblyId)
        {
            PhysicalAssembly wep;
            if (!AssemblyPartManager.I.AllPhysicalAssemblies.TryGetValue(assemblyId, out wep))
                return Array.Empty<IMyCubeBlock>();

            var parts = new List<IMyCubeBlock>();
            foreach (var part in wep.ComponentParts)
                if (part.Block.FatBlock != null)
                    parts.Add(part.Block.FatBlock);

            return parts.ToArray();
        }

        private IMyCubeBlock GetBasePart(int assemblyId)
        {
            PhysicalAssembly wep;
            if (!AssemblyPartManager.I.AllPhysicalAssemblies.TryGetValue(assemblyId, out wep))
                return null;

            return null; //wep.basePart?.block?.FatBlock as IMyCubeBlock;
        }

        private IMyCubeGrid GetAssemblyGrid(int assemblyId)
        {
            PhysicalAssembly wep;
            if (!AssemblyPartManager.I.AllPhysicalAssemblies.TryGetValue(assemblyId, out wep))
                return null;

            return wep.ComponentParts[0].Block.CubeGrid;
        }

        private void AddOnAssemblyClose(Action<int> action)
        {
            AssemblyPartManager.I.OnAssemblyClose += action;
        }

        private void RemoveOnAssemblyClose(Action<int> action)
        {
            AssemblyPartManager.I.OnAssemblyClose -= action;
        }

        private void RecreateAssembly(int assemblyId)
        {
            var assembly = AssemblyPartManager.I.AllPhysicalAssemblies.GetValueOrDefault(assemblyId, null);
            if (assembly == null)
                return;

            foreach (var part in assembly.ComponentParts)
            {
                part.PartRemoved();
                AssemblyPartManager.I.QueueConnectionCheck(part);
            }
        }

        #endregion

        #region Per-Part Methods

        private IMyCubeBlock[] GetConnectedBlocks(IMyCubeBlock block, string definitionName, bool useCached)
        {
            var definition = DefinitionHandler.TryGetDefinition(definitionName);
            if (block == null || definition == null)
                return Array.Empty<IMyCubeBlock>();

            AssemblyPart wep;
            if (!AssemblyPartManager.I.AllAssemblyParts[definition].TryGetValue(block.SlimBlock, out wep) ||
                wep.ConnectedParts == null)
                return Array.Empty<IMyCubeBlock>();

            var parts = new List<IMyCubeBlock>();
            if (useCached)
            {
                foreach (var part in wep.ConnectedParts)
                    if (part.Block.FatBlock != null)
                        parts.Add(part.Block.FatBlock);
            }
            else
            {
                foreach (var part in wep.GetValidNeighbors(true))
                    if (part.FatBlock != null)
                        parts.Add(part.FatBlock);
            }

            return parts.ToArray();
        }

        private int GetContainingAssembly(IMyCubeBlock block, string definitionName)
        {
            var definition = DefinitionHandler.TryGetDefinition(definitionName);
            if (definition == null)
                return -1;

            foreach (var partKvp in AssemblyPartManager.I.AllAssemblyParts[definition])
            {
                if (partKvp.Key != block.SlimBlock)
                    continue;
                return partKvp.Value.MemberAssembly.AssemblyId;
            }

            return -1;
        }

        private void RecreateConnections(IMyCubeBlock block, string definitionName)
        {
            var definition = DefinitionHandler.TryGetDefinition(definitionName);
            if (definition == null)
                return;

            var part = AssemblyPartManager.I.AllAssemblyParts[definition].GetValueOrDefault(block.SlimBlock, null);
            if (part != null)
            {
                part.PartRemoved();
                AssemblyPartManager.I.QueueConnectionCheck(part);
            }
        }

        #endregion
    }
}﻿using System;
using System.Collections.Generic;
using Modular_Assemblies.Data.Scripts.AssemblyScripts.DebugUtils;
using Sandbox.ModAPI;
using VRage;
using VRageMath;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts.Definitions
{
    internal class ApiHandler
    {
        private const long Channel = 8774;
        private readonly IReadOnlyDictionary<string, Delegate> _apiDefinitions;
        private readonly MyTuple<Vector2I, IReadOnlyDictionary<string, Delegate>> _endpointTuple;

        /// <summary>
        ///     Registers for API requests and updates any pre-existing clients.
        /// </summary>
        public ApiHandler()
        {
            _apiDefinitions = new ApiDefinitions().ModApiMethods;
            _endpointTuple =
                new MyTuple<Vector2I, IReadOnlyDictionary<string, Delegate>>(AssembliesSessionInit.ModVersion,
                    _apiDefinitions);

            MyAPIGateway.Utilities.RegisterMessageHandler(Channel, HandleMessage);

            IsReady = true;
            try
            {
                MyAPIGateway.Utilities.SendModMessage(Channel, _endpointTuple);
            }
            catch (Exception ex)
            {
                ModularLog.Log($"Exception in Api Load: {ex}");
            }

            ModularLog.Log($"ModularDefinitionsAPI v{AssembliesSessionInit.ModVersion.Y} initialized.");
        }

        /// <summary>
        ///     Is the API ready?
        /// </summary>
        public bool IsReady { get; private set; }

        private void HandleMessage(object o)
        {
            if (o as string == "ApiEndpointRequest")
            {
                MyAPIGateway.Utilities.SendModMessage(Channel, _endpointTuple);
                ModularLog.Log("ModularDefinitionsAPI sent definitions.");
            }
            else
            {
                ModularLog.Log($"ModularDefinitionsAPI ignored message {o as string}.");
            }
        }


        /// <summary>
        ///     Unloads all API endpoints and detaches events.
        /// </summary>
        public void Unload()
        {
            MyAPIGateway.Utilities.UnregisterMessageHandler(Channel, HandleMessage);

            IsReady = false;
            // Clear API client's endpoints
            MyAPIGateway.Utilities.SendModMessage(Channel,
                new MyTuple<Vector2I, IReadOnlyDictionary<string, Delegate>>(AssembliesSessionInit.ModVersion, null));

            ModularLog.Log("ModularDefinitionsAPI unloaded.");
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Linq;
using Modular_Assemblies.Data.Scripts.AssemblyScripts.DebugUtils;
using Sandbox.Definitions;
using Sandbox.ModAPI;
using VRage.Game.ModAPI;
using static Modular_Assemblies.Data.Scripts.AssemblyScripts.Definitions.DefinitionDefs;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts.Definitions
{
    /// <summary>
    ///     Handles all communication about definitions.
    /// </summary>
    internal class DefinitionHandler
    {
        private const int OutboundMessageId = 8771;
        public static DefinitionHandler I;

        internal ApiHandler ApiHandler;

        public Dictionary<string, ModularDefinition>
            ModularDefinitionsMap = new Dictionary<string, ModularDefinition>();

        /// <summary>
        ///     An array of all valid block subtypes, generated at session init.
        /// </summary>
        internal string[] ValidBlockSubtypes = Array.Empty<string>();

        public ICollection<ModularDefinition> ModularDefinitions => ModularDefinitionsMap.Values;

        public void Init()
        {
            I = this;

            ApiHandler = new ApiHandler();
            ModularLog.Log("DefinitionHandler loading...");
            MyAPIGateway.Session.OnSessionReady += CheckValidDefinitions;
        }

        public void Unload()
        {
            I = null;
            ModularLog.Log("DefinitionHandler closing...");
            MyAPIGateway.Session.OnSessionReady -= CheckValidDefinitions;
            ApiHandler.Unload();
        }

        /// <summary>
        ///     Registers a serialized definition.
        /// </summary>
        /// <param name="serialized"></param>
        /// <returns></returns>
        public string[] RegisterDefinitions(byte[] serialized)
        {
            if (serialized == null)
                return Array.Empty<string>();

            try
            {
                var definitionSet = MyAPIGateway.Utilities.SerializeFromBinary<ModularDefinitionContainer>(serialized);
                return RegisterDefinitions(definitionSet);
            }
            catch (Exception ex)
            {
                ModularLog.Log($"Exception in DefinitionHandler.RegisterDefinitions: {ex}");
            }

            return Array.Empty<string>();
        }

        /// <summary>
        ///     Registers a deserialized definition.
        /// </summary>
        /// <param name="modularDefinitionSet"></param>
        /// <returns></returns>
        public string[] RegisterDefinitions(ModularDefinitionContainer modularDefinitionSet)
        {
            try
            {
                if (modularDefinitionSet == null)
                {
                    ModularLog.Log("Invalid definition container!");
                    return Array.Empty<string>();
                }

                ModularLog.Log($"Received {modularDefinitionSet.PhysicalDefs.Length} definitions.");
                var newValidDefinitions = new List<string>();

                foreach (var def in modularDefinitionSet.PhysicalDefs)
                {
                    var modDef = ModularDefinition.Load(def);
                    if (modDef == null)
                        continue;

                    var isDefinitionValid = true;
                    // Check for duplicates
                    if (ModularDefinitionsMap.ContainsKey(modDef.Name))
                    {
                        ModularLog.Log($"Duplicate DefinitionName for definition {modDef.Name}! Skipping load...");
                        MyAPIGateway.Utilities.ShowMessage("ModularAssemblies",
                            $"Duplicate DefinitionName in definition {modDef.Name}! Skipping load...");
                        isDefinitionValid = false;
                    }

                    if (!isDefinitionValid)
                        continue;

                    ModularDefinitionsMap.Add(modDef.Name, modDef);
                    AssemblyPartManager.I.AllAssemblyParts.Add(modDef, new Dictionary<IMySlimBlock, AssemblyPart>());
                    newValidDefinitions.Add(modDef.Name);

                    if (AssembliesSessionInit.IsSessionInited)
                    {
                        CheckDefinitionValid(modDef);
                        AssemblyPartManager.I
                            .RegisterExistingBlocks(
                                modDef); // We only want to do this if blocks already exist in the world.
                    }
                }

                return newValidDefinitions.ToArray();
            }
            catch (Exception ex)
            {
                ModularLog.Log($"Exception in DefinitionHandler.RegisterDefinitions: {ex}");
            }

            return Array.Empty<string>();
        }

        /// <summary>
        ///     Removes a definition and destroys all assemblies referencing it.
        /// </summary>
        /// <param name="definitionName"></param>
        /// <returns></returns>
        public bool UnregisterDefinition(string definitionName)
        {
            if (!ModularDefinitionsMap.ContainsKey(definitionName))
                return false;

            foreach (var assembly in AssemblyPartManager.I.AllPhysicalAssemblies.Values)
            {
                if (assembly.AssemblyDefinition.Name != definitionName)
                    continue;

                assembly.Close();
            }

            AssemblyPartManager.I.AllAssemblyParts.Remove(ModularDefinitionsMap[definitionName]);
            ModularDefinitionsMap.Remove(definitionName);
            return true;
        }

        public static ModularDefinition TryGetDefinition(string definitionName)
        {
            return I.ModularDefinitionsMap.GetValueOrDefault(definitionName, null);
        }

        public void RegisterOnPartAdd(string definitionName, Action<int, IMyCubeBlock, bool> action)
        {
            var definition = ModularDefinitionsMap.GetValueOrDefault(definitionName, null);

            if (definition == null)
                return;

            definition.OnPartAdd += action;
        }

        public void RegisterOnPartRemove(string definitionName, Action<int, IMyCubeBlock, bool> action)
        {
            var definition = ModularDefinitionsMap.GetValueOrDefault(definitionName, null);

            if (definition == null)
                return;

            definition.OnPartRemove += action;
        }

        public void RegisterOnPartDestroy(string definitionName, Action<int, IMyCubeBlock, bool> action)
        {
            var definition = ModularDefinitionsMap.GetValueOrDefault(definitionName, null);

            if (definition == null)
                return;

            definition.OnPartDestroy += action;
        }

        public void UnregisterOnPartAdd(string definitionName, Action<int, IMyCubeBlock, bool> action)
        {
            var definition = ModularDefinitionsMap.GetValueOrDefault(definitionName, null);

            if (definition == null || action == null)
                return;

            definition.OnPartAdd -= action;
        }

        public void UnregisterOnPartRemove(string definitionName, Action<int, IMyCubeBlock, bool> action)
        {
            var definition = ModularDefinitionsMap.GetValueOrDefault(definitionName, null);

            if (definition == null || action == null)
                return;

            definition.OnPartRemove -= action;
        }

        public void UnregisterOnPartDestroy(string definitionName, Action<int, IMyCubeBlock, bool> action)
        {
            var definition = ModularDefinitionsMap.GetValueOrDefault(definitionName, null);

            if (definition == null || action == null)
                return;

            definition.OnPartDestroy -= action;
        }

        private void CheckValidDefinitions()
        {
            // Get all block definition subtypes
            var defs = MyDefinitionManager.Static.GetAllDefinitions();
            var validSubtypes = new List<string>();
            foreach (var def in defs)
            {
                var blockDef = def as MyCubeBlockDefinition;

                if (blockDef != null) validSubtypes.Add(def.Id.SubtypeName);
            }

            ValidBlockSubtypes = validSubtypes.ToArray();

            foreach (var def in ModularDefinitions.ToList())
                CheckDefinitionValid(def);
        }

        private void CheckDefinitionValid(ModularDefinition modDef)
        {
            foreach (var subtypeId in modDef.AllowedBlocks)
            {
                if (ValidBlockSubtypes.Contains(subtypeId))
                    continue;
                ModularLog.Log(
                    $"Invalid SubtypeId \"{subtypeId}\" in definition {modDef.Name}! Unexpected behavior may occur.");
                MyAPIGateway.Utilities.ShowMessage("ModularAssemblies",
                    $"Invalid SubtypeId [{subtypeId}] in definition {modDef.Name}! Unexpected behavior may occur.");
            }
        }
    }
}﻿using System;
using System.Collections.Generic;
using ProtoBuf;
using Sandbox.ModAPI;
using VRage;
using VRage.Game.ModAPI;
using VRage.Utils;
using VRageMath;

namespace Modular_Assemblies.Data.Scripts.AssemblyScripts.
    Definitions
{
    /// <summary>
    ///     Class used to communicate with the Modular Assemblies Framework mod. <br /><br />
    ///     Want to include in this your own mod? Check out the following documentation link: <br />
    ///     <see href="https://github.com/StarCoreSE/Modular-Assemblies/wiki/The-Modular-API"></see>
    /// </summary>
    public class ModularDefinitionApi
    {
        /// <summary>
        ///     The expected API version. Don't touch this unless you're developing for the Modular Assemblies Framework.
        /// </summary>
        public const int ApiVersion = 1;

        /// <summary>
        ///     Triggered whenever the API is ready - added to by the constructor or manually.
        /// </summary>
        public Action OnReady;

        /// <summary>
        ///     Call this to initialize the Modular API.<br/>
        ///     <remarks>
        ///         API methods will be unusable until the endpoints are populated. Check <see cref="IsReady"/> or utilize <see cref="OnReady"/> for safety.
        ///     </remarks>
        /// </summary>
        /// <param name="modContext"></param>
        /// <param name="onLoad">Method to be triggered when the API is ready.</param>
        /// <exception cref="Exception"></exception>
        public void Init(IMyModContext modContext, Action onLoad = null)
        {
            if (_isRegistered)
                throw new Exception($"{GetType().Name}.Load() should not be called multiple times!");

            _modContext = modContext;
            OnReady = onLoad;
            _isRegistered = true;
            MyAPIGateway.Utilities.RegisterMessageHandler(ApiChannel, HandleMessage);
            MyAPIGateway.Utilities.SendModMessage(ApiChannel, "ApiEndpointRequest");
            MyLog.Default.WriteLineAndConsole(
                $"{_modContext.ModName}: ModularDefinitionsAPI listening for API methods...");
        }

        /// <summary>
        ///     The currently loaded Modular Assemblies Framework version.
        ///     <remarks>
        ///         Not the API version; see <see cref="ApiVersion"/>
        ///     </remarks>
        /// </summary>
        public int FrameworkVersion { get; private set; } = -1;

        /// <summary>
        ///     Displays whether endpoints are loaded and the API is ready for use.
        /// </summary>
        public bool IsReady { get; private set; }

        /// <summary>
        ///     Call this to unload the Modular API; i.e. in case of instantiating a new API or for freeing up resources.
        ///     <remarks>
        ///         This method will also be called automatically when the Modular Assemblies Framework is
        ///         closed.
        ///     </remarks>
        /// </summary>
        public void UnloadData()
        {
            MyAPIGateway.Utilities.UnregisterMessageHandler(ApiChannel, HandleMessage);

            if (_apiInit)
                ApiAssign(); // Clear API methods if the API is currently inited.

            _isRegistered = false;
            _apiInit = false;
            IsReady = false;
            OnReady = null;
            MyLog.Default.WriteLineAndConsole($"{_modContext.ModName}: ModularDefinitionsAPI unloaded.");
        }

        // These sections are what the user can actually see when referencing the API, and can be used freely. //
        // Note the null checks. //

        #region Global Assembly Methods

        /// <summary>
        ///     Gets all AssemblyParts in the world. Returns an array of all AssemblyParts.
        /// </summary>
        public IMyCubeBlock[] GetAllParts()
        {
            return _getAllParts?.Invoke();
        }

        /// <summary>
        ///     Gets all PhysicalAssembly ids in the world. Returns an empty list on fail.
        ///     <para>
        ///         Arg1 is assembly id
        ///     </para>
        /// </summary>
        public int[] GetAllAssemblies()
        {
            return _getAllAssemblies?.Invoke();
        }

        #endregion

        #region Per-Assembly Methods

        /// <summary>
        ///     Gets all member parts of a assembly. Returns an empty list on fail.
        ///     <para>
        ///         Arg1 is EntityId
        ///     </para>
        /// </summary>
        public IMyCubeBlock[] GetMemberParts(int assemblyId)
        {
            return _getMemberParts?.Invoke(assemblyId);
        }

        /// <summary>
        ///     Gets the base part of a PhysicalAssembly. Returns null if assembly does not exist.
        /// </summary>
        public IMyCubeBlock GetBasePart(int assemblyId)
        {
            return _getBasePart?.Invoke(assemblyId);
        }

        /// <summary>
        ///     Returns the IMyCubeGrid containing a given assembly ID.
        /// </summary>
        /// <param name="assemblyId"></param>
        /// <returns></returns>
        public IMyCubeGrid GetAssemblyGrid(int assemblyId)
        {
            return _getAssemblyGrid?.Invoke(assemblyId);
        }

        /// <summary>
        ///     Registers an Action<AssemblyId> triggered on assembly removal.
        /// </summary>
        /// <param name="action"></param>
        public void AddOnAssemblyClose(Action<int> action)
        {
            _addOnAssemblyClose?.Invoke(action);
        }

        /// <summary>
        ///     De-registers an Action(AssemblyId) triggered on assembly removal.
        /// </summary>
        /// <param name="action"></param>
        public void RemoveOnAssemblyClose(Action<int> action)
        {
            _removeOnAssemblyClose?.Invoke(action);
        }

        /// <summary>
        ///     Removes all blocks from the assembly and queues them for a connection check.
        /// </summary>
        /// <param name="assemblyId"></param>
        public void RecreateAssembly(int assemblyId)
        {
            _recreateAssembly?.Invoke(assemblyId);
        }

        #endregion

        #region Per-Part Methods

        /// <summary>
        ///     Gets all connected parts to a block. Returns an empty list on fail.
        ///     <para>
        ///         <paramref name="useCached" />: Set this to 'false' if used in OnPartAdd.
        ///     </para>
        /// </summary>
        public IMyCubeBlock[] GetConnectedBlocks(IMyCubeBlock partBlockId, string definition, bool useCached = true)
        {
            return _getConnectedBlocks?.Invoke(partBlockId, definition, useCached);
        }

        /// <summary>
        ///     Returns the ID of the assembly containing a given part, or -1 if no assembly was found.
        /// </summary>
        /// <param name="blockPart"></param>
        /// <param name="definition"></param>
        /// <returns></returns>
        public int GetContainingAssembly(IMyCubeBlock blockPart, string definition)
        {
            return _getContainingAssembly?.Invoke(blockPart, definition) ?? -1;
        }

        /// <summary>
        ///     Removes a part from its assembly and queues it for a connection check.
        /// </summary>
        /// <param name="blockPart"></param>
        /// <param name="definition"></param>
        public void RecreateConnections(IMyCubeBlock blockPart, string definition)
        {
            _recreateConnections?.Invoke(blockPart, definition);
        }

        #endregion

        #region Definition Methods

        /// <summary>
        ///     Registers a set of definitions with Modular Assemblies Framework.
        /// </summary>
        /// <param name="modularDefinitionContainer"></param>
        /// <returns></returns>
        public string[] RegisterDefinitions(DefinitionDefs.ModularDefinitionContainer modularDefinitionContainer)
        {
            var validDefinitions =
                _registerDefinitions?.Invoke(MyAPIGateway.Utilities.SerializeToBinary(modularDefinitionContainer));

            foreach (var definition in modularDefinitionContainer.PhysicalDefs)
            {
                RegisterOnPartAdd(definition.Name, definition.OnPartAdd);
                RegisterOnPartRemove(definition.Name, definition.OnPartRemove);
                RegisterOnPartDestroy(definition.Name, definition.OnPartDestroy);

                if (validDefinitions.Contains(definition.Name))
                    definition.OnInit?.Invoke();
            }

            return validDefinitions;
        }

        /// <summary>
        ///     Unregisters a definition and removes all parts referencing it.
        /// </summary>
        /// <param name="definitionName"></param>
        /// <returns></returns>
        public bool UnregisterDefinition(string definitionName)
        {
            return _unregisterDefinition?.Invoke(definitionName) ?? false;
        }

        /// <summary>
        ///     Returns a list of all registered definition names.
        /// </summary>
        /// <returns></returns>
        public string[] GetAllDefinitions()
        {
            return _getAllDefinitions?.Invoke();
        }

        /// <summary>
        ///     Registers an action to be triggered when a part is added.
        /// </summary>
        /// <param name="definitionName"></param>
        /// <param name="action"></param>
        public void RegisterOnPartAdd(string definitionName, Action<int, IMyCubeBlock, bool> action)
        {
            if (action == null)
                return;
            _registerOnPartAdd?.Invoke(definitionName, action);
        }

        /// <summary>
        ///     Registers an action to be triggered when a part is removed.
        /// </summary>
        /// <param name="definitionName"></param>
        /// <param name="action"></param>
        public void RegisterOnPartRemove(string definitionName, Action<int, IMyCubeBlock, bool> action)
        {
            if (action == null)
                return;
            _registerOnPartRemove?.Invoke(definitionName, action);
        }

        /// <summary>
        ///     Registers an action to be triggered when a part is destroyed. Triggered immediately after OnPartRemove if a block
        ///     was destroyed.
        /// </summary>
        /// <param name="definitionName"></param>
        /// <param name="action"></param>
        public void RegisterOnPartDestroy(string definitionName, Action<int, IMyCubeBlock, bool> action)
        {
            if (action == null)
                return;
            _registerOnPartDestroy?.Invoke(definitionName, action);
        }

        /// <summary>
        ///     Unregisters an action to be triggered when a part is added.
        /// </summary>
        /// <param name="definitionName"></param>
        /// <param name="action"></param>
        public void UnregisterOnPartAdd(string definitionName, Action<int, IMyCubeBlock, bool> action)
        {
            if (action == null)
                return;
            _unregisterOnPartAdd?.Invoke(definitionName, action);
        }

        /// <summary>
        ///     Unregisters an action to be triggered when a part is removed.
        /// </summary>
        /// <param name="definitionName"></param>
        /// <param name="action"></param>
        public void UnregisterOnPartRemove(string definitionName, Action<int, IMyCubeBlock, bool> action)
        {
            if (action == null)
                return;
            _unregisterOnPartRemove?.Invoke(definitionName, action);
        }

        /// <summary>
        ///     Unregisters an action to be triggered when a part is destroyed.
        /// </summary>
        /// <param name="definitionName"></param>
        /// <param name="action"></param>
        public void UnregisterOnPartDestroy(string definitionName, Action<int, IMyCubeBlock, bool> action)
        {
            if (action == null)
                return;
            _unregisterOnPartDestroy?.Invoke(definitionName, action);
        }

        #endregion

        #region Global Methods

        /// <summary>
        ///     Returns true if debug mode is enabled.
        /// </summary>
        /// <returns></returns>
        public bool IsDebug()
        {
            return _isDebug?.Invoke() ?? false;
        }

        /// <summary>
        ///     Writes a line to the Modular Assemblies log. %AppData%\Space Engineers\Storage\ModularAssemblies.log
        /// </summary>
        /// <param name="text"></param>
        public void Log(string text)
        {
            _logWriteLine?.Invoke($"[{_modContext.ModName}] {text}");
        }

        /// <summary>
        ///     Registers a chat command. Help page is autogenerated and tied into "!md help"
        /// </summary>
        /// <param name="command"></param>
        /// <param name="helpText"></param>
        /// <param name="onTrigger"></param>
        public void AddChatCommand(string command, string helpText, Action<string[]> onTrigger)
        {
            _addChatCommand?.Invoke(command, helpText, onTrigger, _modContext.ModName);
        }

        /// <summary>
        ///     De-registers a chat command.
        /// </summary>
        /// <param name="command"></param>
        public void RemoveChatCommand(string command)
        {
            _removeChatCommand?.Invoke(command);
        }

        #endregion


        // This section lists all the delegates that will be assigned and utilized below. //

        #region Delegates

        // Global assembly methods
        private Func<IMyCubeBlock[]> _getAllParts;
        private Func<int[]> _getAllAssemblies;

        // Per-assembly methods
        private Func<int, IMyCubeBlock[]> _getMemberParts;
        private Func<int, IMyCubeBlock> _getBasePart;
        private Func<int, IMyCubeGrid> _getAssemblyGrid;
        private Action<Action<int>> _addOnAssemblyClose;
        private Action<Action<int>> _removeOnAssemblyClose;
        private Action<int> _recreateAssembly;

        // Per-part methods
        private Func<IMyCubeBlock, string, bool, IMyCubeBlock[]> _getConnectedBlocks;
        private Func<IMyCubeBlock, string, int> _getContainingAssembly;
        private Action<IMyCubeBlock, string> _recreateConnections;

        // Definition methods
        private Func<byte[], string[]> _registerDefinitions;
        private Func<string, bool> _unregisterDefinition;
        private Func<string[]> _getAllDefinitions;
        private Action<string, Action<int, IMyCubeBlock, bool>> _registerOnPartAdd;
        private Action<string, Action<int, IMyCubeBlock, bool>> _registerOnPartRemove;
        private Action<string, Action<int, IMyCubeBlock, bool>> _registerOnPartDestroy;
        private Action<string, Action<int, IMyCubeBlock, bool>> _unregisterOnPartAdd;
        private Action<string, Action<int, IMyCubeBlock, bool>> _unregisterOnPartRemove;
        private Action<string, Action<int, IMyCubeBlock, bool>> _unregisterOnPartDestroy;

        // Global methods
        private Func<bool> _isDebug;
        private Action<string> _logWriteLine;
        private Action<string, string, Action<string[]>, string> _addChatCommand;
        private Action<string> _removeChatCommand;

        #endregion


        // This section is the 'guts' of the API; it assigns out all the API endpoints internally and registers with the main framework mod. //

        #region API Initialization

        private bool _isRegistered;
        private bool _apiInit;
        private const long ApiChannel = 8774;
        private IReadOnlyDictionary<string, Delegate> _methodMap;
        private IMyModContext _modContext;

        /// <summary>
        ///     Assigns all API methods. Internal function, avoid editing.
        /// </summary>
        /// <returns></returns>
        public bool ApiAssign()
        {
            _apiInit = _methodMap != null;

            // Global assembly methods
            SetApiMethod("GetAllParts", ref _getAllParts);
            SetApiMethod("GetAllAssemblies", ref _getAllAssemblies);

            // Per-assembly methods
            SetApiMethod("GetMemberParts", ref _getMemberParts);
            SetApiMethod("GetBasePart", ref _getBasePart);
            SetApiMethod("GetAssemblyGrid", ref _getAssemblyGrid);
            SetApiMethod("AddOnAssemblyClose", ref _addOnAssemblyClose);
            SetApiMethod("RemoveOnAssemblyClose", ref _removeOnAssemblyClose);
            SetApiMethod("RecreateAssembly", ref _recreateAssembly);

            // Per-part methods
            SetApiMethod("GetConnectedBlocks", ref _getConnectedBlocks);
            SetApiMethod("GetContainingAssembly", ref _getContainingAssembly);
            SetApiMethod("RecreateConnections", ref _recreateConnections);

            // Definition methods
            SetApiMethod("RegisterDefinitions", ref _registerDefinitions);
            SetApiMethod("UnregisterDefinition", ref _unregisterDefinition);
            SetApiMethod("GetAllDefinitions", ref _getAllDefinitions);
            SetApiMethod("RegisterOnPartAdd", ref _registerOnPartAdd);
            SetApiMethod("RegisterOnPartRemove", ref _registerOnPartRemove);
            SetApiMethod("RegisterOnPartDestroy", ref _registerOnPartDestroy);
            SetApiMethod("UnregisterOnPartAdd", ref _unregisterOnPartAdd);
            SetApiMethod("UnregisterOnPartRemove", ref _unregisterOnPartRemove);
            SetApiMethod("UnregisterOnPartDestroy", ref _unregisterOnPartDestroy);

            // Global methods
            SetApiMethod("IsDebug", ref _isDebug);
            SetApiMethod("LogWriteLine", ref _logWriteLine);
            SetApiMethod("AddChatCommand", ref _addChatCommand);
            SetApiMethod("RemoveChatCommand", ref _removeChatCommand);

            // Unload data if told to by the framework, otherwise notify that the API is ready.
            if (_methodMap == null)
            {
                UnloadData();
                return false;
            }

            _methodMap = null;
            OnReady?.Invoke();
            return true;
        }

        /// <summary>
        ///     Assigns a single API endpoint.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="name">Shared endpoint name; matches with the framework mod.</param>
        /// <param name="method">Method to assign.</param>
        /// <exception cref="Exception"></exception>
        private void SetApiMethod<T>(string name, ref T method) where T : class
        {
            if (_methodMap == null)
            {
                method = null;
                return;
            }

            if (!_methodMap.ContainsKey(name))
                throw new Exception("Method Map does not contain method " + name);
            var del = _methodMap[name];
            if (del.GetType() != typeof(T))
                throw new Exception(
                    $"Method {name} type mismatch! [MapMethod: {del.GetType().Name} | ApiMethod: {typeof(T).Name}]");
            method = _methodMap[name] as T;
        }

        /// <summary>
        ///     Triggered whenever the API receives a message from the framework mod.
        /// </summary>
        /// <param name="obj"></param>
        private void HandleMessage(object obj)
        {
            try
            {
                if (_apiInit || obj is string ||
                    obj == null) // the "ApiEndpointRequest" message will also be received here, we're ignoring that
                    return;

                var tuple = (MyTuple<Vector2I, IReadOnlyDictionary<string, Delegate>>)obj;
                var receivedVersion = tuple.Item1;
                var dict = tuple.Item2;

                if (dict == null)
                {
                    MyLog.Default.WriteLineAndConsole(
                        $"{_modContext.ModName}: ModularDefinitionsAPI ERR: Received null dictionary!");
                    return;
                }

                if (receivedVersion.Y != ApiVersion)
                    Log(
                        $"Expected API version ({ApiVersion}) differs from received API version {receivedVersion}; errors may occur.");

                _methodMap = dict;

                if (!ApiAssign()) // If we're unassigning the API, don't notify when ready
                    return;

                FrameworkVersion = receivedVersion.X;
                IsReady = true;
                Log($"Modular API v{ApiVersion} loaded!");
            }
            catch (Exception ex)
            {
                // We really really want to notify the player if something goes wrong here.
                MyLog.Default.WriteLineAndConsole($"{_modContext.ModName}: Exception in ModularDefinitionsAPI! " + ex);
                MyAPIGateway.Utilities.ShowMessage(_modContext.ModName, "Exception in ModularDefinitionsAPI!\n" + ex);
            }
        }

        #endregion
    }

    public class DefinitionDefs
    {
        /// <summary>
        /// Stores and serialized an array of definitions.
        /// </summary>
        [ProtoContract]
        public class ModularDefinitionContainer
        {
            [ProtoMember(1)] internal ModularPhysicalDefinition[] PhysicalDefs;
        }

        /// <summary>
        /// Class representing a Modular Assemblies definition.
        /// </summary>
        [ProtoContract]
        public class ModularPhysicalDefinition
        {
            /// <summary>
            ///     The name of this definition. Must be unique!
            /// </summary>
            [ProtoMember(1)]
            public string Name { get; set; }

            /// <summary>
            ///     Triggered whenever the definition is first loaded.
            /// </summary>
            public Action OnInit { get; set; }

            /// <summary>
            ///     Called when a valid part is placed.
            ///     <para>
            ///         Arg1 is PhysicalAssemblyId, Arg2 is BlockEntity, Arg3 is IsBaseBlock
            ///     </para>
            /// </summary>
            public Action<int, IMyCubeBlock, bool> OnPartAdd { get; set; }

            /// <summary>
            ///     Called when a valid part is removed.
            ///     <para>
            ///         Arg1 is PhysicalAssemblyId, Arg2 is BlockEntity, Arg3 is IsBaseBlock
            ///     </para>
            /// </summary>
            public Action<int, IMyCubeBlock, bool> OnPartRemove { get; set; }

            /// <summary>
            ///     Called when a component part is destroyed. Note - OnPartRemove is called simultaneously.
            ///     <para>
            ///         Arg1 is PhysicalAssemblyId, Arg2 is BlockEntity, Arg3 is IsBaseBlock
            ///     </para>
            /// </summary>
            public Action<int, IMyCubeBlock, bool> OnPartDestroy { get; set; }

            /// <summary>
            ///     All allowed SubtypeIds. The mod will likely misbehave if two mods allow the same blocks, so please be cautious.
            /// </summary>
            [ProtoMember(2)]
            public string[] AllowedBlockSubtypes { get; set; }

            /// <summary>
            ///     Allowed connection directions. Measured in blocks. If an allowed SubtypeId is not included here, connections are
            ///     allowed on all sides. If the connection type whitelist is empty, all allowed subtypes may connect on that side.
            /// </summary>
            [ProtoMember(3)]
            public Dictionary<string, Dictionary<Vector3I, string[]>> AllowedConnections { get; set; }

            /// <summary>
            ///     The primary block of a PhysicalAssembly. Make sure this is an AssemblyCore block OR null.
            /// </summary>
            [ProtoMember(4)]
            public string BaseBlockSubtype { get; set; }
        }
    }
}